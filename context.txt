UAV - Research Analysis

Device Configurations:
Raspberry Pi: 4B, 8GB / 64GB
Battery: Pro Range Lipo, 6 Cells, 22.2 V, 35C
Pixhawk: V5, PX4 O.S.

Program Files on RPi:
Mavproxy.py
Cryptography (Drone-side) 
TST1
TST2

Program Files on Windows (GCS):
Pymavlink
Cryptography (GCS-side)
Mavsdk
Mavsdk-server

Delay Analysis via Quantum Cryptography



IPC Analysis
Single Core (taskset -c 0):
mavproxy.py: 0.68 
kyber.py: 0.41
tst1.py: 1.13
tst2.py: 1.12

Observations:
Single-core (taskset -c 0)
sudo cpufreq-set -f 600000 (600 MHz)
Kyber (command receiving delay in seconds): 1.602, 1.776, 3.638, 3.307, 3.937, 2.593, 4.575, 4.667
mavproxy.py: 0.75 insn per cycle
kyber.py: 0.39 insn per cycle
tst1.py: 1.34 insn per cycle
tst2.py 1.34 insn per cycle
Dilithium: 4.219, 3.508, 4.174 5.149, 5.006
mavproxy.py: 0.74 insn per cycle
dilithium.py: 0.81 insn per cycle
tst1.py: 1.21 insn per cycle
tst2.py: 1.21 insn per cycle
Sphincs: 4.128, 3.961, 5.236, 3.724, 4.104
mavproxy.py: 0.76 insn per cycle
sphincs.py: 1.82 insn per cycle
tst1.py: 1.11
tst2.py: 1.12 insn per cycle
Falcon: 4.896, 4.242, 3.555, 5.794, 5.297
mavproxy.py: 0.77 insn per cycle
falcon.py: 0.76 insn per cycle
tst1.py: 1.25 insn per cycle
tst2.py: 1.24 insn per cycle

sudo cpufreq-set -f 1200000 (1.2 gHz)
Kyber: 0.147, 0.178, 0.109, 0.485, 0.129
mavproxy.py: 0.74 insn  per cycle
kyber.py: 0.43 insn per cycle
tst1.py: 1.19 insn per cycle
tst2.py: 1.19 insn per  cycle
Dilithium: 0.248, 0.221, 0.386, 0.257, 0.228
mavproxy.py: 0.71 insn per cycle
dilithium.py: 0.66 insn per cycle
tst1.py: 1.05 insn per cycle
tst2.py: 1.00 insn per cycle
Sphincs: 0.549, 0.86, 0.763, 0.643, 0.776
mavproxy.py: 0.74 insn per cycle
sphincs.py: 1.82 insn per cycle
tst1.py: 1.18 insn per cycle
tst2.py: 1.11 insn per cycle
Falcon: 0.245, 0.783, 0.489, 0.187, 0.222
mavproxy.py: 0.73 insn per cycle
falcon.py: 0.67 insn per cycle
tst1.py: 1.08 insn per cycle
tst2.py: 1.04 insn per cycle

sudo cpufreq-set -f 1800000 (1.8 gHz)
Kyber: 0.094, 0.108, 0.122, 0.128, 0.136
mavproxy.py: 0.67 insn per cycle
kyber.py: 0.43 insn per cycle
tst1.py: 1.02 insn per cycle
tst2.py: 1.01 insn per cycle
Dilithium: 0.441, 0.354, 0.283, 0.157, 0.295
mavproxy.py: 0.66 insn per cycle 
dilithium.py: 0.61 insn per cycle
tst1.py: 1.09 insn per cycle
tst2.py: 1.08 insn per cycle
Sphincs: 0.657, 0.26, 0.291, 0.364, 0.23
mavproxy.py: 0.67 insn per cycle
sphincs.py: 1.78 insn per cycle
tst1.py: 1.05 insn per cycle
tst2.py: 1.07 insn per cycle
Falcon: 0.236, 0.322, 0.294, 0.203, 0.196
mavproxy.py: 0.66 insn per cycle
falcon.py: 0.60 insn per cycle
tst1.py: 1.06 insn per cycle
tst2.py: 1.07 insn per cycle


Double-core (taskset -c 0,1)
sudo cpufreq-set -f 600000 (600 MHz)
Kyber: 0.494, 0.195, 0.116, 0.095, 0.151
mavproxy.py: 0.79 insn per cycle
kyber.py: 0.49 insn per cycle
tst1.py: 1.14 insn per cycle
tst2.py: 1.13 insn per cycle
Dilithium: 1.783, 0.465, 0.231, 0.536, 0.461, 0.176 (Take any 5)
mavproxy.py: 0.80 insn per cycle 
dilithium.py: 0.74 insn per cycle
tst1.py: 1.17 insn per cycle
tst2.py: 1.18 insn per cycle
Sphincs: 1.417, 1.277, 1.318, 1.166, 3.655, 2.047 (Take any 5)
mavproxy.py: 0.85 insn per cycle
sphincs.py: 1.84 insn per cycle
tst1.py: 1.18 insn per cycle
tst2.py: 1.18 insn per cycle
Falcon: 0.29, 0.469, 0.222, 0.313, 0.905
mavproxy.py 0.80 insn per  cycle
falcon.py: 0.76 insn per cycle
tst1.py: 1.09 insn per cycle
tst2.py: 1.11 insn per cycle 

sudo cpufreq-set -f 1200000 (1.2 gHz)
Kyber: 0.135, 0.09, 0.094, 0.121, 0.139
mavproxy.py: 0.78 insn per cycle
kyber.py: 0.50 insn per cycle
tst1.py: 1.13 insn per cycle
tst2.py: 1.16 insn per cycle
Dilithium: 0.266, 0.16, 0.118, 0.235, 0.194
mavproxy.py: 0.76 insn per cycle
dilithium.py: 0.69 insn per cycle
tst1.py: 1.15 insn per cycle
tst2.py: 1.15 insn per cycle
Sphincs: 0.292, 0.36, 0.195, 0.408, 0.32
mavproxy.py: 0.79 insn per cycle
sphincs.py: 1.80 insn per cycle
tst1.py 1.17 insn per cycle
tst2.py: 1.16 insn per cycle
Falcon: 0.115, 0.222, 0.181, 0.189, 0.184
mavproxy.py: 0.78 insn per cycle
falcon.py: 0.68 insn per cycle
tst1.py: 1.16 insn per cycle
tst2.py: 1.15 insn per cycle

sudo cpufreq-set -f 1800000 (1.8 gHz)
Kyber: 0.105, 0.372, 0.091, 0.125, 0.171 
mavproxy.py: 0.71 insn per cycle
kyber.py: 0.42 insn per cycle
tst1.py: 1.20 insn per cycle
tst2.py: 1.19 insn per cycle
Dilithium: 0.12, 0.289, 0.11, 0.255, 0.173
mavproxy.py: 0.73 insn per cycle
dilithium.py: 0.63 insn per cycle
tst1.py: 1.16 insn per cycle
tst2.py: 1.17 insn per cycle
Sphincs: 0.308, 0.146, 0.246, 0.295, 0.167
mavproxy.py: 0.75 insn per cycle
sphincs.py: 1.85 insn per cycle
tst1.py: 1.16 insn per cycle
tst2.py: 1.16 insn per cycle
Falcon: 0.583, 0.154, 0.195, 0.124, 0.619
mavproxy.py: 0.76 insn per cycle 
falcon.py: 0.63 insn per cycle
tst1.py: 1.18 insn per cycle
tst2.py: 1.18 insn per cycle

Triple-core (taskset -c 0,1,2)
sudo cpufreq-set -f 600000 (600 MHz)
Kyber: 0.131, 0.094, 0.454, 0.236, 0.123
mavproxy.py: 0.73 insn per cycle
kyber.py: 0.46 insn per cycle
tst1.py: 1.09 insn per cycle
tst2.py: 1.10 insn per cycle

Dilithium: 0.249, 0.135, 0.146, 0.464, 0.122
mavproxy.py:	0.79 insn per cycle
dilithium.py: 0.73 insn per cycle
tst1.py: 1.10 insn per cycle
tst2.py: 1.09 insn per cycle

Sphincs: 0.326, 0.263, 0.439, 0.267, 0.299
mavproxy.py: 0.80 insn per cycle
sphincs.py: 1.85 insn per cycle
tst1.py: 1.11 insn per cycle
tst2.py:  1.12 insn per cycle
Falcon: 0.226, 0.717, 0.339, 0.096, 0.358
mavproxy.py: 0.77 insn per cycle
falcon.py: 0.70 insn per cycle
tst1.py: 1.10 insn per cycle
tst2.py: 1.10 insn per cycle

sudo cpufreq-set -f 1200000 (1.2 gHz)
Kyber: 0.101, 0.11, 0.089, 0.094, 0.111
mavproxy.py: 0.70 insn per cycle
kyber.py: 0.40 insn per cycle
tst1.py: 1.14 insn per cycle
tst2.py: 1.13 insn per cycle
Dilithium: 0.112, 0.233, 0.259, 0.224, 0.307
mavproxy.py: 0.73 insn per cycle
dilithium.py: 0.62 insn per cycle
tst1.py: 1.15 insn per cycle
tst2.py: 1.16 insn per cycle
Sphincs: 0.25, 0.197, 0.156, 0.144, 0.136
mavproxy.py: 0.74 insn per cycle
sphincs.py: 1.85 insn per cycle
tst1.py: 1.13 insn per cycle
tst2.py: 1.14 insn per cycle
Falcon: 0.377, 0.146, 0.216, 0.188, 0.163
mavproxy.py: 0.72 insn per cycle
falcon.py: 0.63 insn per cycle
tst1.py: 1.14 insn per cycle
tst2.py: 1.14 insn per cycle

sudo cpufreq-set -f 1800000 (1.8 gHz)
Kyber: 0.104, 0.102, 0.094, 0.093, 0.093
mavproxy.py: 0.64 insn per cycle
kyber.py: 0.35 insn per cycle
tst1.py: 1.14 insn per cycle
tst2.py: 1.13 insn per cycle
Dilithium: 0.147, 0.245, 0.111, 0.109, 0.103
mavproxy.py: 0.70 insn per cycle
dilithium.py: 0.60 insn per cycle
tst1.py: 1.14 insn per cycle
tst2.py: 1.15 insn per cycle
Sphincs: 0.167, 0.122, 0.125, 1.043, 0.114, 0.117 (Take any 5)
mavproxy.py: 0.71 insn per cycle
sphincs.py: 1.86 insn per cycle
tst1.py: 1.17 insn per cycle
tst2.py: 1.18 insn per cycle
Falcon: 0.155, 0.308, 0.237, 0.134, 0.306
mavproxy.py: 0.68 insn per cycle
falcon.py: 0.60 insn per cycle
tst1.py: 1.10 insn per cycle
tst2.py: 1.10 insn per cycle

Quad-core (taskset -c 0,1,2,3)
sudo cpufreq-set -f 600000 (600 MHz)
Kyber: 0.159, 0.239, 0.118, 0.302, 0.21
mavproxy.py: 0.67 insn per cycle
kyber.py: 0.38 insn per cycle
tst1.py: 1.40 insn per cycle
tst2.py: 1.39 insn per cycle
Dilithium: 1.083, 0.767, 0.878, 1.373, 1.86
mavproxy.py: 0.71 insn per cycle
dilithium.py: 0.66 insn per cycle
tst1.py: 1.43 insn per cycle
tst2.py: 1.42 insn per cycle
Sphincs: 1.717, 1.455, 1.408, 0.563, 0.957
mavproxy.py: 0.75 insn per cycle
sphincs.py: 1.84 insn per cycle
tst1.py: 1.45 insn per cycle
tst2.py: 1.47 insn per cycle
Falcon: 0.948, 1.161, 0.958, 1.081, 1.242
mavproxy.py: 0.71 insn per cycle
falcon.py: 0.67 insn per cycle
tst1.py: 1.39 insn per cycle
tst2.py: 1.38 insn per cycle

Sudo cpufreq-set -f 12000000 (1.2 GHz)
Kyber: 0.098, 0.306, 0.135, 0.769, 0.197
mavproxy.py: 0.57 insn per cycle
kyber.py: 0.31 insn per cycle
tst1.py: 1.38 insn per cycle
tst2.py: 1.41 insn per cycle
Dilithium: 0.155, 0.22, 0.388, 0.424, 0.515
mavproxy.py: 0.62 insn per cycle
dilithium.py: 0.56 insn per cycle
tst1.py: 1.41 insn per cycle 
tst2.py: 1.36 insn per cycle
Sphincs: 0.289, 0.156, 0.222, 0.139, 0.22
mavproxy.py: 0.68 insn per cycle
sphincs.py: 1.63 insn per cycle
 tst1.py: 1.44 insn per cycle
tst2.py: 1.46 insn per cycle
Falcon: 0.411, 0.389, 0.155, 0.359, 0.517
mavproxy.py: 0.60 insn per cycle
falcon.py: 0.54 insn per cycle
tst1.py: 1.43 insn per cycle
tst2.py: 1.39 insn per cycle
sudo cpufreq-set -f 1800000 (1.8 GHz)
Kyber: 0.107, 0.134, 0.224, 0.168, 0.09
mavproxy.py: 0.49 insn per cycle
kyber.py: 0.26 insn per cycle
tst1.py: 1.41 insn per cycle
tst2.py: 1.39 insn per cycle
Dilithium: 0.322, 0.237, 0.376, 0.536, 0.117
mavproxy.py: 0.50 insn per cycle
dilithium.py: 0.50 insn per cycle
tst1.py: 1.39 insn per cycle
tst2.py: 1.40 insn per cycle
Sphincs: 1.004, 0.132, 0.749, 0.273, 0.154, 0.324 (Take any 5)
mavproxy.py: 0.58 insn per cycle
sphincs.py: 1.85 insn per cycle
tst1.py: 1.42 insn per cycle
tst2.py: 1.41 insn per cycle
Falcon: 0.229, 0.112, 0.116, 0.205, 0.188
mavproxy.py: 0.48 insn per cycle
falcon.py: 0.46 insn per cycle
tst1.py: 1.40 insn per cycle
tst2.py: 1.40 insn per cycle


Current Analysis  
  #    Single-core (other 3 are offline)
600 MHz - max: 0.97 Amp, min: 0.80 Amp, min: 5.17 V, max: 5.19 V
1.2GHz  - max: 1.06 Amp 
1.8GHz   - max: 1.17 Amp

Single-core (taskset -c 0)
Kyber (min: 0.79 Amp at 600 Mhz)
600 Mhz - max: 1.01 Amp
1.2 Ghz  - max: 1.07 Amp
1.8 GHz - max:  1.24 Amp
Dilithium (min: 0.80 Amp at 600 Mhz)
600 Mhz - max: 0.98 Amp
1.2 Ghz  -  max:  1.08 Amp
1.8 Ghz  -  max: 1.16 Amp
SPHINCS (min: 0.79 Amp at 600 Mhz)
600 Mhz - max: 0.96 Amp
1.2 Ghz  - max: 1.08 Amp
1.8 Ghz  - max: 1.17 Amp
Falcon (min: 0.80 Amp at 600 Mhz)
600 Mhz - max: 1.00 Amp
1.2 Ghz  - max: 1.07 Amp 
1.8 Ghz  - max: 1.18 Amp
Double-core (taskset -c 0,1)
Kyber (min: 0.79 Amp at 600 Mhz)
600 Mhz - max: 0.99 Amp
1.2 Ghz  - max: 1.10 Amp
1.8 Ghz  - max: 1.30 Amp
Dilithium (min: 0.79 Amp at 600 Mhz)
600 Mhz - max: 1.02 Amp
1.2 Ghz  - max: 1.12 Amp
1.8 Ghz  - max: 1.22 Amp
Sphincs (min: 0.80 Amp at 600 Mhz)
600 Mhz - max: 1.01 Amp
1.2 Ghz  - max: 1.15 Amp
1.8 Ghz  - max: 1.27 Amp
Falcon (min: 0.79  Amp at 600 Mhz)
600 Mhz - max: 0.99 Amp
1.2 Ghz  - max: 1.12 Amp
1.8 Ghz  - max: 1.23 Amp
Triple-core (taskset -c 0,1,2)
Kyber (min: 0.82 Amp at 600 Mhz)
600 Mhz - max: 1.07 Amp
1.2 Ghz  - max: 1.22 Amp
1.8 Ghz  - max: 1.47 Amp
Dilithium (min: 0.82 Amp at 600 Mhz)
600 Mhz - max: 1.00 Amp
1.2 Ghz  - max: 1.22 Amp
1.8 Ghz  - max: 1.42 Amp
Sphics (min:0.84 Amp at 600 Mhz)
600 Mhz - max: 1.06 Amp
1.2 Ghz  - max: 1.29 Amp
1.8 Ghz  - max: 1.46 Amp
Falcon (min: 0.84 Amp at 600 Mhz)
600 Mhz - max: 1.05 Amp
1.2 Ghz  - max: 1.28 Amp
1.8 Ghz  - max: 1.47 Amp
Quad-core (taskset -c 0,1,2,3)
Kyber (min: 0.87 Amp at 600 Mhz)
600 Mhz - max: 1.14 Amp
1.2 Ghz  - max: 1.34 Amp
1.8 Ghz  - max: 1.68 Amp
Dilithium (min: 0.88  Amp at 600 Mhz)
600 Mhz - max: 1.14 Amp
1.2 Ghz  - max: 1.39 Amp
1.8 Ghz  - max: 1.68 Amp
Sphincs (min: 0.86 Amp at 600 Mhz)
600 Mhz - max: 1.17 Amp
1.2 Ghz  - max: 1.36 Amp
1.8 Ghz  - max: 1.67 Amp
Falcon (min: 0.89 Amp at 600 Mhz)
600 Mhz - max: 1.16 Amp
1.2 Ghz  - max: 1.38 Amp
1.8 Ghz  - max: 1.67 Amp



	





Table: Analysis of RPi 4B Configurations for Drone Hover Mode	
Configuration
Frequency
Cores
Current Draw (A)
Power Consumption (W)
Time Delay (s)
Flight Time (minutes)
Single-core
600 MHz
1
0.79–1.01
3.95–5.05
1.6–5.8
27.0–27.1
Single-core
1.2 GHz
1
1.07–1.08
5.35–5.40
0.1–0.8
27.0–27.1
Single-core
1.8 GHz
1
1.16–1.24
5.80–6.20
0.09–0.3
26.9–27.0
Double-core
600 MHz
2
0.79–1.02
3.95–5.10
0.09–0.5
27.0–27.1
Double-core
1.2 GHz
2
1.10–1.15
5.50–5.75
0.09–0.5
27.0–27.1
Double-core
1.8 GHz
2
1.22–1.30
6.10–6.50
0.09–0.3
26.9–27.0
Triple-core
600 MHz
3
0.82–1.07
4.10–5.35
0.09–0.5
27.0–27.1
Triple-core
1.2 GHz
3
1.22–1.29
6.10–6.45
0.09–0.5
26.9–27.0
Triple-core
1.8 GHz
3
1.42–1.47
7.10–7.35
0.09–0.3
26.8–26.9
Quad-core
600 MHz
4
0.86–1.17
4.30–5.85
0.09–0.5
26.9–27.1
Quad-core
1.2 GHz
4
1.34–1.39
6.70–6.95
0.09–0.5
26.8–26.9
Quad-core
1.8 GHz
4
1.67–1.68
8.35–8.40
0.09–0.3
26.7–26.8




Decryption Time (in seconds):

600MHz
Kyber:
Single-core: 0.0011, 0.0011, 0.0170
Double-core: 0.0022, 0.0009, 0.0011
Triple-core: 0.0008, 0.0013, 0.0032
Quad-core: 0.0015, 0.0012, 0.0015
Dilithium:
Single-core: 0.0019, 0.0013, 0.0013
Double-core: 0.0633, 0.0013, 0.0013
Triple-core: 0.0046, 0.0049, 0.0012
Quad-core: 0.0022, 0.0020, 0.0015
SPHINCS:
Single-core: 0.2302, 0.0854, 0.2963
Double-core: 0.0478, 0.0988, 0.0592
Triple-core: 0.0810, 0.0903, 0.0584
Quad-core: 0.3560, 0.0189, 0.0650 
Falcon:
Single-core: 0.0015, 0.0010, 0.0007
Double-core:0.0012, 0.0012, 0.0011
Triple-core: 0.0807, 0.0010, 0.0011
Quad-core: 0.0047, 0.0011, 0.0008

1200MHz
Kyber:
Single-core: 0.0005, 0.0006, 0.0003
Double-core: 0.0006, 0.0005, 0.0005
Triple-core: 0.0006, 0.0006, 0.0004
Quad-core: 0.0005, 0.0005, 0.0008 
Dilithium:
Single-core: 0.0012, 0.0007, 0.0007
Double-core: 0.0010, 0.0007, 0.0007
Triple-core: 0.0011, 0.0007, 0.0007
Quad-core: 0.0013, 0.0009, 0.0020
SPHINCS:
Single-core: 0.1381, 0.1203, 0.0725
Double-core: 0.0235, 0.0254, 0.0282
Triple-core: 0.0249, 0.0133, 0.0238
Quad-core: 0.0364, 0.0657, 0.0240  
Falcon:
Single-core: 0.0009, 0.0040, 0.0039
Double-core: 0.0008, 0.0004, 0.0006
Triple-core: 0.0008, 0.0005, 0.0054
Quad-core: 0.0010, 0.0006, 0.0006

18000MHz 

Kyber:
Single-core: 0.0004, 0.0005, 0.0015
Double-core: 0.0004, 0.0004, 0.0004
Triple-core: 0.0009, 0.0004, 0.0003
Quad-core: 0.0046, 0.0015, 0.0024
Dilithium:
Single-core: 0.0054, 0.0033, 0.0005
Double-core: 0.0008, 0.0005, 0.0005
Triple-core: 0.0008, 0.0006, 0.0005
Quad-core: 0.0033, 0.0007, 0.0007
SPHINCS:
Single-core: 0.0581, 0.0738, 0.0603
Double-core: 0.0186, 0.0084,  0.0079
Triple-core: 0.0084. 0.0415, 0.0145
Quad-core: 0.0340, 0.0084, 0.0163  
Falcon:
Single-core: 0.0007, 0.0004, 0.0003
Double-core: 0.0006, 0.0004, 0.0003
Triple-core: 0.0006, 0.0004, 0.0004
Quad-core: 0.0009, 0.0005, 0.0006 
TST
Frequency
Core
Function
Call Count
Total Time(sec)
600 MHz
Single
load_model
1
0,0977




dry_run
0
0




create_squence
1
13.5459




get_prediction_time
0
0


Double
load_model
1
0.0554




dry_run
0
0




create_squence
1
8.7863




get_prediction_time
0
0


Triple
load_model
1
0.0553




dry_run
0
0




create_squence
1
8.8293




get_prediction_time
0
0


Quad
load_model
1
0.0540




dry_run
0
0




create_squence
1
8.8759




get_prediction_time
0
0










1.2 GHz
Single
load_model
1
0,0271




dry_run
0
0




create_squence
1
5.0813




get_prediction_time
0
0


Double
load_model
1
0.0321




dry_run
0
0




create_squence
1
4.1946




get_prediction_time
0
0


Triple
load_model
1
0.0258




dry_run
0
0




create_squence
1
4.2098




get_prediction_time
0
0


Quad
load_model
1
0.0262




dry_run
0
0




create_squence
1
4.1985




get_prediction_time
0
0










1.8 GHz
Single
load_model
1
0,0452




dry_run
0
0




create_squence
1
3.2256




get_prediction_time
0
0


Double
load_model
1
0.0190




dry_run
0
0




create_squence
1
2.7212




get_prediction_time
0
0


Triple
load_model
1
0.0196




dry_run
0
0




create_squence
1
2.7831




get_prediction_time
0
0


Quad
load_model
1
0.0208




dry_run
0
0




create_squence
1
2.8066




get_prediction_time
0
0






DDOS Pipeline
P.T. = Prediction Time, O/P = Output

Frequency
Core
Process
Iteration
P.T (ms)
O/P
600 MHz
Single
DDOS Detection
22
3.90
0




DDOS Mitigation
22




Storage Output
22




DDOS Preprocess
23


Double
DDOS Detection
26
46.17
1




DDOS Mitigation
26




Storage Output
26




DDOS Preprocess
27


Triple
DDOS Detection
29
50.31
1




DDOS Mitigation
29




Storage Output
29




DDOS Preprocess
30


Quad
DDOS Detection
30
50.38
1




DDOS Mitigation
30




Storage Output
30




DDOS Preprocess
31












1.2 GHz
Single
DDOS Detection
35
2.20
0




DDOS Mitigation
35




Storage Output
35




DDOS Preprocess
36


Double
DDOS Detection
38
21.75
0




DDOS Mitigation
38




Storage Output
38




DDOS Preprocess
39


Triple
DDOS Detection
40
55.75
0




DDOS Mitigation
40




Storage Output
40




DDOS Preprocess
41


Quad
DDOS Detection
42
59.62
1




DDOS Mitigation
42




Storage Output
42




DDOS Preprocess
43












1.8 GHz
Single
DDOS Detection
53
1.58
0




DDOS Mitigation
53




Storage Output
53




DDOS Preprocess
54


Double
DDOS Detection
50
39.21
1




DDOS Mitigation
50




Storage Output
50




DDOS Preprocess
51


Triple
DDOS Detection
49
41.43
0




DDOS Mitigation
49




Storage Output
49




DDOS Preprocess
50


Quad
DDOS Detection
48
45.65
0




DDOS Mitigation
48




Storage Output
48




DDOS Preprocess
49
Attention Meets UAVs: A Comprehensive Evaluation of DDoS Detection in Low-Cost UAVs
Publisher: IEEE
Cite This
PDF
Ashish Sharma; Svsln Surya Suhas Vaddhiparthy; Sai Usha Goparaju; Deepak Gangadharan; Harikumar Kandath
All Authors

1
Cites in
Paper

88
Full
Text Views

Abstract
Document Sections
I.
Introduction
II.
Related Works
III.
DDoS Attack Framework and Scenario
IV.
DDoS Detection
V.
Experimental Setup
Show Full Outline
Authors
Figures
References
Citations
Keywords
Metrics
Abstract:
This paper explores the critical issue of enhancing cybersecurity measures for low-cost, Wi-Fi-based Unmanned Aerial Vehicles (UAVs) against Distributed Denial of Service (DDoS) attacks. In the current work, we have explored three variants of DDoS attacks, namely Transmission Control Protocol (TCP), Internet Control Message Protocol (ICMP), and TCP + ICMP flooding attacks, and developed a detection mechanism that runs on the companion computer of the UAV system. As a part of the detection mechanism, we have evaluated various machine learning, and deep learning algorithms, such as XGBoost, Isolation Forest, Long Short-Term Memory (LSTM), Bidirectional-LSTM (Bi-LSTM), LSTM with attention, Bi-LSTM with attention, and Time Series Transformer (TST) in terms of various classification metrics. Our evaluation reveals that algorithms with attention mechanisms outperform their counterparts in general, and TST stands out as the most efficient model with a run time of ~0.1 seconds. TST has demonstrated an F1 score of 0.999, 0.997, and 0.943 for TCP, ICMP, and TCP + ICMP flooding attacks respectively. In this work, we present the necessary steps required to build an onboard DDoS detection mechanism. Further, we also present the ablation study to identify the best TST hyperparameters for DDoS detection, and we have also underscored the advantage of adapting learnable positional embeddings in TST for DDoS detection with an improvement in F1 score from 0.94 to 0.99.
Published in: 2024 IEEE 20th International Conference on Automation Science and Engineering (CASE)
Date of Conference: 28 August 2024 - 01 September 2024
Date Added to IEEE Xplore: 23 October 2024
ISBN Information:
ISSN Information:
DOI: 10.1109/CASE59546.2024.10711508
Publisher: IEEE
Conference Location: Bari, Italy
SECTION I.Introduction
Technological innovations have recently spread their wings through Unmanned Aerial Vehicles (UAVs), marking a dawn of advancements in aerial ingenuity. These advances have resulted in unparalleled growth of UAV adaptation, particularly low-cost UAVs, which are anticipated to reach USD 42.8 billion in the market by 2025 [1]. The autonomy and cost-effectiveness combined with the agile nature of low-cost UAVs have drastically increased their visibility in various applications, such as Traffic Management, Healthcare, Disaster Response and Mega Sporting Events [2].

As the use of UAVs proliferates across various applications, scalability and reliable connectivity requirements become paramount for a UAV-based approach. Amidst the available approaches, Wi-Fi-based UAV connectivity emerges as one potential solution to enable the full capabilities of a UAV system [3]. One can establish resilient networks supporting swarm deployments by leveraging WiFi technology [4].

Fig. 1 illustrates a general Wi-Fi-based UAV system involving a Central Router, Ground Control Station (GCS), and a UAV system. A typical UAV system uses a MicroAir-Vehicle link (MAVlink), a lightweight open-source communication protocol for seamless two-way communication between the GCS and the UAV system. MAVlink adapts a binary serialization approach for overhead-free communication between the devices in the network. Despite its widespread usage and development, this protocol is vulnerable to numerous security attacks, such as spoofing, Denial of Service (DoS), and message foraging attacks [5] [6].

Fig. 1: - 
General Wi-Fi-based UAV System

Fig. 1:
General Wi-Fi-based UAV System

Show All

According to Esentire’s 2023 Official Cybercrime report [7], the global annual cost of cybercrime is predicted to reach USD 9.5 trillion in 2024 and is projected to reach USD 10.5 trillion by 2025. The report highlights that this heightened risk can pertain to the explosion in mobile, cloud [8], Internet of Things (IoT) usage, and remote tools. The Cybersecurity statistics report by Cobalt [9] highlights that Distributed Denial of Service (DDoS), Ransomware, and Phishing attacks hold a predominant share as the first-hand choices of the attackers. The report particularly emphasizes that resource constraint edge applications such as IoT devices and UAVs fall prey to DDoS attacks significantly, making DDoS one of the most calamitous forms of cyber security attack [10].

On the other hand, multiple stakeholders opted to integrate AI with cybersecurity detection [6] in the endeavor to find a solution. Nevertheless, these efforts were promptly halted as this approach raised privacy and security issues according to the General Data Protection Regulation (GDPR) [9], as the detection models required data to be transferred outside the resource-constrained system for processing. Considering the UAV system’s resource-constrained nature, it is vital to deploy a resource-efficient mechanism on the UAV system to hinder any potential DDoS attacks. A general-purpose UAV system is equipped with a companion computer [6] capable of running a routine or a lightweight task. Therefore, an efficient approach can involve deploying a DDoS Detection model on the companion computer of the UAV system. Based on this notion, in the current work, we conduct a comprehensive evaluation considering various algorithms for DDoS Detection.

The contributions of our work are as follows.

We present the necessary pre-processing steps to collect a comprehensive dataset while conducting flooding attacks on UAVs, as there is a scarcity of diverse datasets tailored explicitly for such attacks.

We evaluate the feasibility of deploying Machine Learning (ML) and Deep Learning (DL) architectures on resource-constrained UAV companion computers for DDoS detection. Specifically, we have evaluated various algorithms, such as XGBoost (XGB), Isolation Forest (IF), Long Short-Term Memory (LSTM), Bidirectional-LSTM (Bi-LSTM), LSTM with attention (LSTM-A), Bi-LSTM with attention (BLSTM-A), and Time Series Transformer (TST) in terms of various classification metrics against three flooding attacks: TCP, ICMP, and TCP with ICMP.

To the best of our knowledge, for the first time, we have explored the capability of TST and compared it with other attention mechanisms for DDoS attack detection in UAVs. We have also conducted an ablation study to identify the best TST hyperparameters and presented the significance of learnable-positional embeddings in improving the F1 score.

SECTION II.Related Works
This section presents the UAV network attack scenario, followed by literature on DDoS attacks and detection mechanisms.

A. UAV Network Attack Scenario
Numerous studies [6], [11], [12] have outlined the importance and benefits of adapting Wi-Fi-based UAVs. UAV systems use intermediate network nodes in either a centralized or decentralized manner for data exchange. A centralized network uses a router-based approach to control and maintain network devices. On the other hand, a decentralized network uses another network node for data exchange. A centralized network node can act as a single-point vulnerability as it can support collaborative attacks such as DDoS, making it crucial to analyze [13]. The existing works have adopted ML and DL algorithms for DDoS detection of TCP and ICMP attacks but not a mix of two DDOS flooding attacks.

B. DDoS Attacks
Due to increased complexity and frequency, DDoS attacks have become a prominent research problem. Lee et al. has unveiled the first taxonomy and classification details of DDoS attacks and their effects [14]. These attacks can significantly compromise the network and computation resources of the target, making this calamitous for edge and UAV devices. DDoS attacks can often be characterized by fluctuating network traffic, which can be statistically analyzed [15]. An efficient DDoS attack usually involves network tools to generate attacks such as TCP and ICMP flooding, which ML algorithms can detect. However, these approaches can particularly fail when a hybrid DDoS attack involving a mix of TCP with ICMP flooding is considered. The current work evaluates the performance of various ML and DL algorithms for TCP, ICMP, and TCP with ICMP attack modes in a WiFi-based low-cost UAV system.

C. DDoS Detection
As emphasized in several works [6], [16], ML and DL have demonstrated the capabilities of efficient DDoS detection. For instance, the work by Tlili et al. [17] has developed a general fault detection mechanism using LSTM, Bi-LSTM, and Gated Recurrent Unit algorithms. The authors have emphasized and demonstrated the capabilities and advantages of using Bi-LSTM for multi-fault-class detection scenarios. Further, the authors have mentioned the need and necessity for studying longer sequences to detect potential anomalies in a UAV scenario. Although efficient, Vaswani et al.’s work [18] has proven the unparalleled capabilities of transformers with positional encoding and multi-head self-attention mechanism can better capture the long-term dependencies than LSTM, Bi-LSTM based approaches in general. In the current work, we have adapted the Time Series Transformer (TST) [19], a modified and more suitable version of the original transformer architecture for time series analysis for DDoS detection.

The rest of the paper is organized as follows. Section III shows how these attacks work, ways to detect them in Section IV, our setup for experiments in Section V, and the results we found shown in Section VI. Finally, Section VII presents conclusions and ideas for future research.

SECTION III.DDoS Attack Framework and Scenario
In the current work, three DDoS flooding attacks are considered to analyze the effect of a DDoS attack on a WiFi-based UAV system. The overall system architecture and the different flooding attacks are elaborated below.

A. Overall Flooding Architecture
Fig. 2 illustrates the overall DDoS architecture with three flooding approaches: TCP flooding, ICMP flooding, and TCP with ICMP flooding. A typical DDoS attack generates numerous DoS messages through single or multiple compromised devices. Each DoS message is assigned unique Internet Protocol (IP) and Media Access Control (MAC) addresses to mask their origins. These random messages then target the UAV system’s IP address, ultimately leading to compromised network bandwidth for the UAV system. The central router is the primary focal point for receiving the flood of illegitimate traffic and authentic information from the GCS. This information is then forwarded to the target UAV system.

B. DDoS Flooding Approaches
TCP flooding and ICMP flooding are common approaches used in DDoS attacks to compromise the network bandwidth. The specific and general input parameters used in the Hping3 tool (an open-source packet generator) [20], for TCP and ICMP flooding are populated in [21] (refer Table I).

1) TCP Flooding
TCP flooding involves transmitting many TCP connection requests to the target system from single or multiple sources, rendering it difficult for the target system to differentiate between legitimate and malicious traffic.

2) ICMP Flooding
ICMP flooding involves sending a barrage of incorrectly defined ICMP packets to the target system. The target system attempts to respond to each received request, ultimately leading to exhausted network bandwidth.

3) TCP With ICMP Flooding
This hybrid attack involves transmitting many TCP connection requests to the target while simultaneously sending a barrage of incorrectly defined ICMP packets to the target system. Two parallel instances of the Hping3 tool can be used for generating this hybrid attack.

Fig. 2: - 
System Architecture for DDoS Flooding Attacks

Fig. 2:
System Architecture for DDoS Flooding Attacks

Show All

SECTION IV.DDoS Detection
In this section, we delve into the DDoS Detection mechanism that runs on the companion computer of the UAV system. Fig. 3 illustrates the pipeline for DDoS attack detection on the companion computer of the UAV system using Pix-hawk flight control hardware. The network interface of the companion computer receives the MAVlink communication packets along with DDoS flood packets. All the incoming packets are then captured and forwarded to the packet queue for pre-processing, after which the classification algorithm is used for DDoS attack detection. MAVProxy, an open-source tool [22], acts as a proxy bridge to enable Wi-Fi-based data communication for the UAV system.

Fig. 3: - 
System Pipeline for companion computer based DDoS Detection for UAVs using Pixhawk flight controller

Fig. 3:
System Pipeline for companion computer based DDoS Detection for UAVs using Pixhawk flight controller

Show All

A. Data Collection for Model Training and Evaluation
The incoming network traffic is captured using Wireshark, an open-source packet analyzer [23]. The packet capture component of Wireshark captures the relative arrival time, packet description, protocol name, the sequence length of the incoming benign traffic, and the malicious traffic generated by Hping3 [20].

The training and testing data consist of continuous 10-minute captures of normal traffic followed by 10 minutes of DDoS attack traffic, designed to evaluate DDoS detection algorithms. The training data includes "Normal + TCP" and "Normal + ICMP" scenarios, capturing 60,401 and 73,663 benign packets, and 121,401 and 86,929 malicious packets, respectively. The testing data includes these scenarios plus a mixed "Normal + TCP and ICMP" scenario. "Normal + TCP" captured 54,203 benign and 110,945 malicious packets, "Normal + ICMP" captured 54,203 benign and 165,073 malicious packets, and the mixed scenario captured 36,025 benign and 441,442 malicious packets.

B. Data Pre-Processing
In the current work, the MAVLink packet count is used as the classification feature to identify potential DDoS attacks. A sliding window of 0.1 seconds is considered to aggregate the number of MAVLink packets arrived based on relative arrival times. The aggregated data is then binary encoded with zero as the normal condition and one as the DDoS condition. Fig. 4 illustrates the variation in total MAVLink packet count over a window of 0.1 seconds. It can be observed that MAVLink packets decrease significantly during a DDoS attack, thereby making it a resourceful indicator for classification. However, a time series sequence in the variation of MAVlink packet count can better identify a malicious scenario.

Keeping the training data, which has normal, TCP, and ICMP traffic information as a reference, Standard Scaler is applied to each of the testing conditions, where the mean value is subtracted from each of the test conditions, and then the result is divided by the standard deviation of the data.

Fig. 4: - 
MAVLink Packet count in a DDoS attack

Fig. 4:
MAVLink Packet count in a DDoS attack

Show All

C. Proposed Time Series Transformer model
The TST by George et al. [19] has generalized transformer architecture for time series analysis, unlike the baseline transformer architecture by Vaswani et al. [18]. This uses an encoder-only approach to perform classification and regression analysis. Fig. 5 illustrates the currently adapted TST architecture. The input data sequence is projected by a 1D convolution layer to match the dimension of the encoder layer. In contrast to the sinusoidal embeddings in the original transformer, here, fully learnable positional encodings are added to the output of the 1D convolution layer, which is given as the keys, queries, and values to the multi-head self-attention layer. Multi-head self-attention helps retain the longer sequences of DDoS data. The output of the attention layer is batch-normalized, after which it is provided as an input to the feed-forward network. A sigmoid function is used to threshold the output for classification. In the current work, we have considered six parameters, namely, length of input sequence, dimension of encoder, number of attention heads, dimension of feed-forward network, number of encoder layers, and dropout for tuning the classification performance of the TST model. The parameter length of input sequence determines the length of the input sequence given as an input. Since each entry in the data is created at 0.1 seconds, a sequence length of 400 would translate to past 40 seconds of variations in MAVLink packet count. The parameter dimension of encoder determines the dimension of the input data to the encoder model, number of attention heads is the number of attention head elements given as input to create the attention vector, dimension of feed-forward network is the size of the feed-forward network, number of encoder layers is the number of cascaded encoder layers before the classification head, and dropout is used to randomly prune the transformer to prevent over-fitting during the training phase. Keeping the data pre-processing approach the same, six algorithms: XGBoost, Isolation Forest, LSTM, Bi-LSTM, LSTM with attention, and Bi-LSTM with attention are adopted as the comparison algorithms to evaluate the classification performance of our proposed Time Series Transformer. The description of these models and their necessary hyper-parameters are elaborated in [21].

Fig. 5: - 
Architecture of Time Series Transformer

Fig. 5:
Architecture of Time Series Transformer

Show All

SECTION V.Experimental Setup
This section sheds light on various hardware and software components used in the current work for DDoS Attack and Detection. The description of the UAV system, Hardware, and Software components are as follows.

The different onboard components of the custom-built quadcopter used in this work are shown in [21] (refer Fig. 6). PixHawk 2.4.8 is used as the flight controller. It provides various sensors capable of sensing positional information through the integrated IMU and magnetometer. The other onboard components include a Radio Telemetry for control information exchange with the GCS and a UBlox Neo-M8N Module [24].

The UAV System includes Raspberry Pi 4B [25] as an onboard companion computer. MAVProxy, an open-source GCS, acts as a proxy bridge to enable Wi-Fi-based data communication for the UAV system and also enables companion computing [22]. MAVProxy uses MAVlink 2.0 protocol encapsulated in TCP/UDP Header for data communication between UAV system and GCS.

TABLE I: Performance Evaluations for TCP, ICMP and TCP+ICMP Floodings
Table I:- 
Performance Evaluations for TCP, ICMP and TCP+ICMP Floodings

A. Hardware Components
The various hardware components used in the current work are as follows:

GCS and Attacker Systems: GCS and Attacker systems use identical configurations. The system is a Ryzen 7 5825U Octa-core processor with Radeon Graphics clocked at 2000 MHz. The system runs with 16 GB of RAM and 512 GB of Solid-State Storage, and an 802.11ac WiFi transceiver.

Companion Computer: Raspberry Pi 4B, a general purpose and versatile system, is chosen as the Companion Computer and the Central Router. This 64-bit Quadcore SoC runs at 1.5GHz with support for 802.11 b/g/n/ac standards [25].

SECTION VI.Experiments and Results
In this section, we evaluate the classification performance of various algorithms for DDoS detection. We then present the memory utilization and inference time for these algorithms. Following that, we present ablation study results to evaluate the best hyperparameters for the TST.

All the algorithms are trained and tested on the Colab notebook using Nvidia T4 GPU. Inference time for the algorithms is calculated on RPI-4B 8 GB RAM. The various results are as follows:

A. Performance Evaluation
In this section, we present the performance evaluation of XGB, IF, LSTM, Bi-LSTM, LSTM-A, BLSTM-A for three kinds of flooding attacks TCP, ICMP and TCP with ICMP as shown in Table I. The model’s effectiveness is evaluated using performance metrics including F1 score, accuracy, recall, and precision.

TCP Flooding: The significant deviation in classification accuracy of XGB, IF, and other algorithms can be explained by the time series nature of LSTMs, and TST-based algorithms. It can be observed that the adoption of the attention mechanism has significantly improved TCP Flood detection owing to the extended capabilities of the attention mechanism to analyze longer sequences. TST algorithm stands out with maximum performance across all the metrics due to its capability to handle longer sequences with learned positional embeddings.

ICMP Flooding: A similar trend, such as TCP flooding evaluation, can be observed for ICMP flood detection. However, unlike TCP flooding, the Bi-LSTM-A algorithm drastically decreases classification efficiency, while TST presents a consistent performance. This can be explained by multiple encoder layers of the TST architecture adopted in the current work. Multiple encoder layers can efficiently help identify the hidden trends in the data.

TCP + ICMP Flooding: TST algorithm follows a consistent efficiency in classifying a hybrid DDoS scenario involving TCP and ICMP attacks. This unparalleled performance can be explained by the capabilities of transformer architecture to better capture the trends and variations in the data due to the presence of the multi-head self-attention along with the multiple encoders, which are absent in other algorithms.

B. Analysis of Memory and Prediction Time
TABLE II: Computational analysis of test data on RPI-4B
Table II:- 
Computational analysis of test data on RPI-4B

We analyzed the memory usage and inference time for each algorithm on the companion computer of the UAV system. Table II shows that algorithms with attention mechanisms require more memory and inference time than their counterparts without attention, as the mechanism requires additional computation to handle the input data. While the TST model outperforms the other algorithms, it incurs a higher memory and inference time due to the presence of multiple encoder layers for DDoS detection. Although TST has the highest inference time, the practical implication can be sustainable in a flight scenario as the inference time is nearly 0.1 seconds.

C. TST Ablation Study
TABLE III: F1 score vs Sequence Length, F1 score vs Encoder Size
Table III:- 
F1 score vs Sequence Length, F1 score vs Encoder Size

TABLE IV: F1 score vs Num of heads, F1 score vs Feed forward size
Table IV:- 
F1 score vs Num of heads, F1 score vs Feed forward size

TABLE V: F1 score vs Num of encoders, F1 score vs Dropout
Table V:- 
F1 score vs Num of encoders, F1 score vs Dropout

Tables III, IV, and V present the variation in sequence length and encoder size. TST model goes through a transitional phase from a sub-optimal F1 score to an optimal score at 400 sequence length, which can be explained by the dependency of DDoS detection on longer sequences. TST reaches the optimal F1 score for a smaller encoder and feed-forward network size of 64, which the simplicity of input data can explain. The need for attention mechanisms in longer sequences for DDoS detection can explain the higher number of attention heads and encoder layers. The dropout rate reaches the optimal F1 score at a lower value of 0,1 owing to a smaller feed-forward network and the encoder size. The optimal hyper-parameters of the proposed TST algorithm and the effect of learnable positional embedding for efficient DDoS detection are presented in [21].

SECTION VII.Conclusion and Future Scope
Low-cost UAV systems have become prominent due to their ease of use. A typical low-cost UAV uses Wi-Fi-based information exchange, making them vulnerable to various cybersecurity attacks such as Distribute Denial of Service (DDoS) attacks. In the current work, we first present the suitable steps and pre-processing to handle DDoS network data. We have then evaluated various ML and DL algorithms such as XGBoost, Isolation Forest, Long Short-Term Memory (LSTM), Bidirectional-LSTM (Bi-LSTM), LSTM with attention, Bi-LSTM with attention, and Time Series Transformer (TST) for DDoS detection considering three variants of DDoS attacks namely: TCP, ICMP, and TCP + ICMP attacks. Our evaluation indicates that the proposed TST model outperforms the other ML and DL algorithms. TST has demonstrated an F1 score of 0.999, 0.997, and 0.943 for TCP, ICMP, and TCP + ICMP flooding attacks. We have also conducted a TST ablation analysis for finetuning the hyperparameters and we have also emphasized the advantage of adapting learnable positional embeddings in TST for DDoS detection. We plan to extend this work to build a DDoS mitigation algorithm for various UAV flight scenarios as part of our future work.

---------------
#!/usr/bin/env python3
"""
Restored GCS MQTT Scheduler GUI (functional) with MQTT protocol fallback.
Fixes:
 - Removes use of clean_session when protocol=5 (avoids error "Clean session is not used for MQTT 5.0").
 - Adds adaptive client creation for MQTT v3.1.1 vs v5.
 - Ensures connect returns proper status and offline retained message published.
"""

import os, sys, json, time, ssl, re, queue, socket, logging, threading, subprocess, signal, importlib
from pathlib import Path
from dataclasses import dataclass
from typing import Dict, Optional, Tuple, Any

# Optional modules
try:
    import ip_config  # user-provided central IP config
except Exception:
    ip_config = None

try:
    import paho.mqtt.client as mqtt
except ImportError:
    print("Install paho-mqtt: pip install paho-mqtt>=1.6.0"); sys.exit(1)

try:
    from pymavlink import mavutil
    PYMAVLINK_AVAILABLE = True
except Exception:
    mavutil = None
    PYMAVLINK_AVAILABLE = False

# Tkinter
try:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog
except Exception as e:
    print("Tkinter required:", e); sys.exit(1)

APP_NAME = "GCS MQTT Scheduler"
HERE = Path(__file__).parent.resolve()
LOG_DIR = HERE / "logs"; LOG_DIR.mkdir(exist_ok=True)
LOG_FILE = LOG_DIR / "gcs_mqtt_scheduler.log"

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', handlers=[logging.StreamHandler(sys.stdout), logging.FileHandler(LOG_FILE, encoding='utf-8')])
logger = logging.getLogger("GCS-SCHED")
PYTHON_EXE = sys.executable

DEFAULT_CONFIG: Dict[str, Any] = {
    "broker": {"address": "localhost", "port": 8883, "keepalive": 60, "connection_timeout": 15},
    "client": {"id": "gcs", "protocol": 4},  # protocol: 4 = MQTTv311, 5 = MQTTv5
    "security": {
        "cert_paths": [
            "C:/mqtt/certs", "C\\mqtt\\certs",
            str(HERE / "certs"), str(HERE.parent / "certs"),
            "/home/dev/mqtt/certs", "/etc/mqtt/certs"
        ],
        "ca_cert": "ca-cert.pem",
        "verify_hostname": False
    },
    "topics": {
        "subscribe": [
            {"topic": "swarm/status/+", "qos": 1},
            {"topic": "swarm/alert/+", "qos": 2},
            {"topic": "swarm/drones/+/telemetry", "qos": 1},
            {"topic": "swarm/broadcast/crypto", "qos": 2},
            {"topic": "swarm/broadcast/alert", "qos": 2},
            {"topic": "swarm/heartbeat/+", "qos": 1},
            {"topic": "swarm/#", "qos": 0}
        ],
        "publish": {
            "alerts": {"topic": "swarm/broadcast/alert", "qos": 2},
            "crypto": {"topic": "swarm/broadcast/crypto", "qos": 2},
            "individual": {"topic": "swarm/commands/individual/{drone_id}", "qos": 1},
            "status": {"topic": "swarm/status/gcs", "qos": 1}
        }
    },
    "core": {"script": "gcs_pymavlink_final.py", "args": ["--no-input"]},
    "mavlink": {"rx_uri": "udp:0.0.0.0:14550", "tx_uri": "udpout:127.0.0.1:14551", "sysid": 255, "compid": 190},
    "crypto_map": {
        "c1": {"name": "ASCON_128", "script": "gcs_ascon_proxy_final.py"},
        "c2": {"name": "KYBER_CRYPTO", "script": "gcs_oqs_proxy_updated.py"},
        "c3": {"name": "DILITHIUM2", "script": "gcs_oqs_proxy_dilithium3.py"},
        "c4": {"name": "FALCON512", "script": "gcs_oqs_proxy_falcon.py"},
        "c5": {"name": "CAMELLIA", "script": "Pre_Quantum_Cryptography/custom_camellia/gcs_camellia.py"},
        "c6": {"name": "SPECK", "script": "gcs_speck_proxy_final.py"},
        "c7": {"name": "HIGHT", "script": "gcs_HIGHT_CBC_proxy.py"},
        "c8": {"name": "AES-256-GCM", "script": "gcs_oqs_proxy_SPHINCS+-SHA2-128f-simple.py"}
    }
}

# --- Utilities ---
def is_windows(): return os.name == 'nt'

# Safe process terminator across platforms
def terminate_process_tree(proc: subprocess.Popen):
    if not proc: return
    try:
        if is_windows():
            try: proc.send_signal(signal.CTRL_BREAK_EVENT)
            except Exception: subprocess.run(["taskkill", "/F", "/T", "/PID", str(proc.pid)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        else:
            os.killpg(os.getpgid(proc.pid), 15)
    except Exception:
        try: proc.terminate()
        except Exception: pass

# --- Certificate discovery ---

def discover_certs(cfg: Dict[str, Any], client_id: str) -> Optional[Tuple[str,str,str]]:
    paths = cfg["security"].get("cert_paths", [])
    ca_name = cfg["security"].get("ca_cert", "ca-cert.pem")
    client_cert = f"{client_id}-cert.pem"; client_key = f"{client_id}-key.pem"
    for base in paths:
        bp = Path(base)
        if not bp.exists(): continue
        ca_path = bp / ca_name
        for flat in (True, False):
            if flat:
                cert_path = bp / client_cert; key_path = bp / client_key
            else:
                cert_path = bp / "clients" / client_cert; key_path = bp / "clients" / client_key
            if ca_path.exists() and cert_path.exists() and key_path.exists():
                logger.info(f"Using certs from: {bp}")
                return str(ca_path), str(cert_path), str(key_path)
    logger.error("Certificates not found")
    return None

# --- MQTT Client ---
class GcsMqttClient:
    def __init__(self, config: Dict[str, Any], on_message_cb):
        self.config = config; self.client_id = config["client"]["id"]
        self.on_message_cb = on_message_cb
        self.connected_event = threading.Event()
        self.metrics = {"rx":0, "tx":0, "errors":0}
        self.connected = False
        self.client: Optional[mqtt.Client] = None
        self.certs = discover_certs(config, self.client_id)
        if not self.certs: raise FileNotFoundError("TLS certs missing")
        self._setup_client()
    def _setup_client(self):
        proto_cfg = self.config["client"].get("protocol", 4)
        if proto_cfg == 5:
            self.client = mqtt.Client(client_id=self.client_id, protocol=mqtt.MQTTv5)
        else:
            self.client = mqtt.Client(client_id=self.client_id, protocol=mqtt.MQTTv311, clean_session=True)
        self.client.on_connect = self._on_connect
        self.client.on_disconnect = self._on_disconnect
        self.client.on_message = self._on_message
        self.client.on_publish = self._on_publish
        ca, cert, key = self.certs
        verify_hostname = self.config["security"].get("verify_hostname", False)
        self.client.tls_set(ca_certs=ca, certfile=cert, keyfile=key, tls_version=ssl.PROTOCOL_TLS, cert_reqs=ssl.CERT_REQUIRED)
        self.client.tls_insecure_set(not verify_hostname)
    def connect(self) -> bool:
        try:
            self.client.connect_async(self.config["broker"]["address"], self.config["broker"]["port"], self.config["broker"].get("keepalive",60))
            self.client.loop_start()
            if self.connected_event.wait(self.config["broker"].get("connection_timeout",15)):
                return True
            logger.error("MQTT connect timeout")
            return False
        except Exception as e:
            logger.error(f"MQTT connect error: {e}")
            return False
    def disconnect(self):
        try: self.client.disconnect(); self.client.loop_stop()
        except Exception: pass
    def _on_connect(self, client, userdata, flags, rc, properties=None):
        if rc == 0:
            self.connected = True; self.connected_event.set()
            for sub in self.config["topics"]["subscribe"]:
                client.subscribe(sub["topic"], sub.get("qos",1))
            # retain online
            self.publish(self.config["topics"]["publish"]["status"]["topic"], {"status":"online","ts":time.time()}, qos=1, retain=True)
            logger.info("Connected to broker")
        else:
            logger.error(f"Connect failed rc={rc}")
    def _on_disconnect(self, client, userdata, rc, properties=None):
        self.connected = False; self.connected_event.clear()
        logger.warning(f"Disconnected (rc={rc})")
    def _on_message(self, client, userdata, msg):
        self.metrics["rx"] += len(msg.payload)
        try: self.on_message_cb(msg)
        except Exception as e:
            logger.error(f"on_message error: {e}"); self.metrics["errors"] += 1
    def _on_publish(self, client, userdata, mid): pass
    def publish(self, topic: str, payload: Any, qos:int=1, retain:bool=False)->bool:
        if not self.connected: return False
        try:
            data = payload if isinstance(payload,(bytes,bytearray)) else (payload if isinstance(payload,str) else json.dumps(payload))
            try: self.metrics["tx"] += len(data)
            except Exception: self.metrics["tx"] += len(str(data))
            r = self.client.publish(topic, data, qos=qos, retain=retain)
            return r.rc == mqtt.MQTT_ERR_SUCCESS
        except Exception as e:
            logger.error(f"Publish error: {e}")
            return False

# --- Crypto Manager ---
class GcsCryptoManager:
    def __init__(self, config: Dict[str, Any]):
        self.config=config; self.current_code=None; self.proc:Optional[subprocess.Popen]=None
    def _script_path(self, name:str)->Path: return (HERE / name).resolve()
    def switch(self, code:str)->Tuple[bool,str]:
        m=self.config.get("crypto_map",{})
        if code not in m: return False, f"Unknown crypto code: {code}"
        if self.current_code==code and self.proc and self.proc.poll() is None:
            return True, f"Already running {m[code]['name']} ({code})"
        self.stop(); target=m[code]; path=self._script_path(target['script'])
        if not path.exists(): return False, f"Script not found: {path}";
        try:
            if is_windows():
                self.proc=subprocess.Popen([PYTHON_EXE,str(path)], creationflags=subprocess.CREATE_NEW_PROCESS_GROUP)
            else:
                self.proc=subprocess.Popen([PYTHON_EXE,str(path)], preexec_fn=os.setsid)
            self.current_code=code
            return True, f"Started {target['name']} ({code}) via {path.name}"
        except Exception as e:
            return False, f"Failed to start {path.name}: {e}"
    def stop(self):
        if self.proc and self.proc.poll() is None:
            try: terminate_process_tree(self.proc)
            except Exception:
                try: self.proc.kill()
                except Exception: pass
        self.proc=None; self.current_code=None

# --- Core Manager ---
class GcsCoreManager:
    def __init__(self, config: Dict[str, Any]): self.config=config; self.proc:Optional[subprocess.Popen]=None
    def _script_path(self)->Path: return (HERE / self.config.get("core",{}).get("script","gcs_pymavlink_final.py")).resolve()
    def start(self)->Tuple[bool,str]:
        if self.proc and self.proc.poll() is None: return True, "Core already running"
        path=self._script_path();
        if not path.exists(): return False, f"Core script not found: {path}"
        args=self.config.get("core",{}).get("args",[])
        try:
            if is_windows():
                self.proc=subprocess.Popen([PYTHON_EXE,str(path),*map(str,args)], creationflags=subprocess.CREATE_NEW_PROCESS_GROUP, stdin=subprocess.DEVNULL)
            else:
                self.proc=subprocess.Popen([PYTHON_EXE,str(path),*map(str,args)], preexec_fn=os.setsid, stdin=subprocess.DEVNULL)
            return True, f"Started core: {path.name}"
        except Exception as e:
            return False, f"Failed to start core: {e}"
    def stop(self):
        if self.proc and self.proc.poll() is None:
            try: terminate_process_tree(self.proc)
            except Exception:
                try: self.proc.kill()
                except Exception: pass
        self.proc=None

# --- MAVLink Manager ---
class GcsMavlinkManager:
    def __init__(self,on_msg_cb=None):
        self.on_msg_cb=on_msg_cb; self.running=False; self.rx_conn=None; self.tx_conn=None; self.rx_thread=None
        self._udp_rx_sock=None; self._udp_tx_sock=None; self._udp_tx_addr=None
        self.sysid=255; self.compid=190; self.hb_running=False; self.hb_thread=None
    def start(self, rx_uri:str, tx_uri:str, sysid:int, compid:int)->Tuple[bool,str]:
        if self.running: return True, "MAVLink already running"
        self.sysid, self.compid = sysid, compid
        try:
            if PYMAVLINK_AVAILABLE:
                self.tx_conn = mavutil.mavlink_connection(tx_uri, source_system=sysid, source_component=compid)
                self.rx_conn = mavutil.mavlink_connection(rx_uri, autoreconnect=True)
            else:
                def _parse(u):
                    p=u.split(":"); assert len(p)>=3; return p[0],p[1],int(p[2])
                _,host_rx,port_rx=_parse(rx_uri); _,host_tx,port_tx=_parse(tx_uri)
                self._udp_rx_sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM); self._udp_rx_sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
                self._udp_rx_sock.bind((host_rx,port_rx)); self._udp_rx_sock.settimeout(1.0)
                self._udp_tx_sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM); self._udp_tx_addr=(host_tx,port_tx)
            self.running=True
            self.rx_thread=threading.Thread(target=self._rx_loop, daemon=True); self.rx_thread.start()
            return True, "MAVLink started"
        except Exception as e:
            self.stop(); return False, f"MAVLink start failed: {e}"
    def send_heartbeat(self):
        if not PYMAVLINK_AVAILABLE or not self.tx_conn: return False, "pymavlink not available for heartbeat"
        try:
            self.tx_conn.mav.heartbeat_send(mavutil.mavlink.MAV_TYPE_GCS, mavutil.mavlink.MAV_AUTOPILOT_INVALID,0,0,0)
            return True, "Heartbeat sent"
        except Exception as e: return False, f"HB send fail: {e}"
    def _hb_loop(self, rate_hz:float):
        it=1.0/max(rate_hz,0.1)
        while self.hb_running and self.running:
            self.send_heartbeat(); time.sleep(it)
    def start_heartbeat(self, rate_hz:float=1.0):
        if self.hb_running or not PYMAVLINK_AVAILABLE: return
        self.hb_running=True; self.hb_thread=threading.Thread(target=self._hb_loop, args=(rate_hz,), daemon=True); self.hb_thread.start()
    def stop_heartbeat(self): self.hb_running=False
    def stop(self):
        self.running=False
        for obj in [self.rx_conn, self.tx_conn, self._udp_rx_sock, self._udp_tx_sock]:
            try: obj and obj.close()
            except Exception: pass
        self.rx_conn=self.tx_conn=None; self._udp_rx_sock=self._udp_tx_sock=None; self._udp_tx_addr=None
    def _rx_loop(self):
        while self.running:
            try:
                if PYMAVLINK_AVAILABLE and self.rx_conn:
                    msg=self.rx_conn.recv_match(blocking=True, timeout=1.0)
                    if not msg: continue
                    if self.on_msg_cb: self.on_msg_cb(msg)
                elif self._udp_rx_sock:
                    data,addr=self._udp_rx_sock.recvfrom(4096)
                    if self.on_msg_cb: self.on_msg_cb({"raw":data, "from":addr})
                else:
                    time.sleep(0.2)
            except Exception:
                pass
    def send_command_long(self,target_sys:int,target_comp:int,command:int,params:list[float])->Tuple[bool,str]:
        try:
            if PYMAVLINK_AVAILABLE and self.tx_conn:
                p=(params+[0.0]*7)[:7]; self.tx_conn.mav.command_long_send(target_sys,target_comp,command,0,*p)
                return True, "Command sent"
            return False, "Install pymavlink or use Raw"
        except Exception as e: return False, f"Send failed: {e}"
    def send_raw(self,data:bytes)->Tuple[bool,str]:
        try:
            if PYMAVLINK_AVAILABLE and self.tx_conn:
                self.tx_conn.write(data); return True, "Raw sent"
            elif self._udp_tx_sock and self._udp_tx_addr:
                self._udp_tx_sock.sendto(data,self._udp_tx_addr); return True, "Raw sent"
            return False, "TX not init"
        except Exception as e: return False, f"Raw send failed: {e}"

# --- Data Structures ---
@dataclass
class DroneInfo:
    drone_id: str; last_seen: float; online: bool; battery: Optional[float]=None; crypto: Optional[str]=None; last_msg_type: Optional[str]=None; hb_count:int=0

# --- Main App ---
class GcsSchedulerApp:
    def __init__(self, root: tk.Tk, config: Dict[str, Any]):
        self.root=root; self.config=config; root.title(APP_NAME)
        self.style=ttk.Style()
        try: self.style.theme_use("vista" if is_windows() and "vista" in self.style.theme_names() else "clam")
        except Exception: pass
        self.msg_queue: "queue.Queue[mqtt.MQTTMessage]" = queue.Queue(); self.mqtt:Optional[GcsMqttClient]=None
        self.crypto=GcsCryptoManager(config); self.core=GcsCoreManager(config)
        self.mav=GcsMavlinkManager(self._on_mav_rx)
        self.mav_rx_uri=tk.StringVar(value=config["mavlink"]["rx_uri"]); self.mav_tx_uri=tk.StringVar(value=config["mavlink"]["tx_uri"])
        self.mav_sysid=tk.IntVar(value=config["mavlink"]["sysid"]); self.mav_compid=tk.IntVar(value=config["mavlink"]["compid"])
        self.mav_status=tk.StringVar(value="MAVLink: stopped" + (" (pymavlink OK)" if PYMAVLINK_AVAILABLE else " (raw UDP mode)"))
        self.mav_auto_hb=tk.BooleanVar(value=True)
        self.mav_tgt_sys=tk.IntVar(value=1); self.mav_tgt_comp=tk.IntVar(value=1); self.mav_cmd_id=tk.IntVar(value=400)
        self.mav_p=[tk.DoubleVar(value=0.0) for _ in range(7)]; self.mav_raw_hex=tk.StringVar(value="")
        self.drones: Dict[str, DroneInfo] = {}
        self.auto_local_crypto=tk.BooleanVar(value=True); self.auto_start_core=tk.BooleanVar(value=True)
        self.core_status_lbl=None; self.proxy_status_lbl=None
        self.sel_id=tk.StringVar(value="-"); self.sel_online=tk.StringVar(value="-"); self.sel_batt=tk.StringVar(value="-")
        self.sel_crypto=tk.StringVar(value="-"); self.sel_msg=tk.StringVar(value="-"); self.sel_last=tk.StringVar(value="-")
        self.sb_conn=tk.StringVar(value="Disconnected"); self.sb_core=tk.StringVar(value="Core: stopped"); self.sb_proxy=tk.StringVar(value="Proxy: stopped"); self.sb_stats=tk.StringVar(value="Drones: 0/0 | Rx: 0B Tx: 0B")
        self._suppress_broadcast_until=0.0; self._last_crypto_pub=None; self._dark_mode=tk.BooleanVar(value=False)
        self.ipc_gcs=tk.StringVar(value=getattr(ip_config,'GCS_HOST',''))
        self.ipc_drone=tk.StringVar(value=getattr(ip_config,'DRONE_HOST',''))
        self._build_ui(); self._start_mqtt_thread(); self._ui_tick()
    # Menubar
    def _build_menubar(self):
        mb=tk.Menu(self.root); m_file=tk.Menu(mb,tearoff=0); m_file.add_command(label="Exit",command=self.root.quit); mb.add_cascade(label="File",menu=m_file)
        m_act=tk.Menu(mb,tearoff=0); m_act.add_command(label="Connect",command=self._connect); m_act.add_separator(); m_act.add_command(label="Start Core",command=self._start_core); m_act.add_command(label="Stop Core",command=self._stop_core); m_act.add_command(label="Start Proxy",command=self._start_proxy); m_act.add_command(label="Stop Proxy",command=self._stop_proxy); m_act.add_command(label="Start Stack",command=self._start_stack); m_act.add_separator(); m_act.add_command(label="Apply Crypto",command=self._apply_crypto); mb.add_cascade(label="Actions",menu=m_act)
        m_help=tk.Menu(mb,tearoff=0); m_help.add_command(label="About",command=lambda: messagebox.showinfo(APP_NAME,"GCS MQTT Scheduler\nSecure control UI with MQTT+TLS, proxy and core orchestration.")); mb.add_cascade(label="Help",menu=m_help); self.root.config(menu=mb)
    def _apply_theme(self, theme_name: str):
        try:
            self.style.theme_use(theme_name)
            # Mild accent adjustments
            if self._dark_mode.get():
                self.root.configure(bg='#1e1e1e')
            else:
                self.root.configure(bg='SystemButtonFace' if is_windows() else '#ececec')
        except Exception as e:
            self._log(f"Theme error: {e}")

    def _toggle_dark(self):
        self._dark_mode.set(not self._dark_mode.get())
        if self._dark_mode.get():
            self.root.configure(bg='#1e1e1e')
            self.log_txt.configure(bg='#111', fg='#d0d0d0', insertbackground='white') if hasattr(self, 'log_txt') else None
            if hasattr(self, 'mav_rx_txt'):
                self.mav_rx_txt.configure(bg='#111', fg='#d0d0d0', insertbackground='white')
        else:
            self.root.configure(bg='SystemButtonFace' if is_windows() else '#ececec')
            self.log_txt.configure(bg='white', fg='black') if hasattr(self, 'log_txt') else None
            if hasattr(self, 'mav_rx_txt'):
                self.mav_rx_txt.configure(bg='white', fg='black')

    # UI
    def _build_ui(self):
        # Menu
        self._build_menubar()
        # Notebook layout
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill=tk.BOTH, expand=True)

        # Control tab
        control_tab = ttk.Frame(notebook)
        notebook.add(control_tab, text="Control")

        # Connection group
        lf_conn = ttk.LabelFrame(control_tab, text="Connection", padding=8)
        lf_conn.pack(fill=tk.X, padx=8, pady=6)
        ttk.Label(lf_conn, text="Broker:").pack(side=tk.LEFT)
        self.broker_entry = ttk.Entry(lf_conn, width=24)
        self.broker_entry.insert(0, self.config["broker"]["address"])
        self.broker_entry.pack(side=tk.LEFT, padx=4)
        ttk.Label(lf_conn, text=":" ).pack(side=tk.LEFT)
        self.port_entry = ttk.Entry(lf_conn, width=6)
        self.port_entry.insert(0, str(self.config["broker"]["port"]))
        self.port_entry.pack(side=tk.LEFT, padx=4)
        self.connect_btn = ttk.Button(lf_conn, text="Connect", command=self._connect)
        self.connect_btn.pack(side=tk.LEFT, padx=6)
        self.status_lbl = ttk.Label(lf_conn, text="Disconnected", foreground="red")
        self.status_lbl.pack(side=tk.LEFT, padx=10)

        # System group
        lf_sys = ttk.LabelFrame(control_tab, text="System", padding=8)
        lf_sys.pack(fill=tk.X, padx=8, pady=6)
        ttk.Checkbutton(lf_sys, text="Auto start core (pymavlink)", variable=self.auto_start_core).pack(side=tk.LEFT)
        ttk.Button(lf_sys, text="Start Core", command=self._start_core).pack(side=tk.LEFT, padx=6)
        ttk.Button(lf_sys, text="Stop Core", command=self._stop_core).pack(side=tk.LEFT)
        ttk.Separator(lf_sys, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=8)
        ttk.Button(lf_sys, text="Start Proxy", command=self._start_proxy).pack(side=tk.LEFT, padx=6)
        ttk.Button(lf_sys, text="Stop Proxy", command=self._stop_proxy).pack(side=tk.LEFT)
        ttk.Button(lf_sys, text="Start Stack", command=self._start_stack).pack(side=tk.LEFT, padx=6)
        self.core_status_lbl = ttk.Label(lf_sys, text="Core: stopped")
        self.core_status_lbl.pack(side=tk.LEFT, padx=8)
        self.proxy_status_lbl = ttk.Label(lf_sys, text="Proxy: stopped")
        self.proxy_status_lbl.pack(side=tk.LEFT, padx=8)

        # Crypto group
        lf_crypto = ttk.LabelFrame(control_tab, text="Crypto Management", padding=8)
        lf_crypto.pack(fill=tk.X, padx=8, pady=6)
        ttk.Label(lf_crypto, text="Algorithm:").pack(side=tk.LEFT)
        self.crypto_var = tk.StringVar(value="c1")
        codes = list(self.config["crypto_map"].keys())
        names = [f"{c} - {self.config['crypto_map'][c]['name']}" for c in codes]
        self.crypto_combo = ttk.Combobox(lf_crypto, values=names, state="readonly", width=40)
        self.crypto_combo.current(0)
        self.crypto_combo.pack(side=tk.LEFT, padx=6)
        ttk.Checkbutton(lf_crypto, text="Auto switch local", variable=self.auto_local_crypto).pack(side=tk.LEFT, padx=8)
        ttk.Button(lf_crypto, text="Apply", command=self._apply_crypto).pack(side=tk.LEFT, padx=6)

        # Broadcast group
        lf_bcast = ttk.LabelFrame(control_tab, text="Broadcast Alerts", padding=8)
        lf_bcast.pack(fill=tk.X, padx=8, pady=6)
        ttk.Button(lf_bcast, text="CAUTION", command=lambda: self._send_alert("alb-cau", False)).pack(side=tk.LEFT, padx=4)
        ttk.Button(lf_bcast, text="CRITICAL", command=lambda: self._send_alert("alb-cri", True)).pack(side=tk.LEFT, padx=4)

        # Fleet tab
        fleet_tab = ttk.Frame(notebook)
        notebook.add(fleet_tab, text="Fleet")
        paned = ttk.PanedWindow(fleet_tab, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True, padx=8, pady=6)
        # Left: table
        left = ttk.Frame(paned)
        cols = ("drone", "online", "battery", "crypto", "msg", "last")
        self.tree = ttk.Treeview(left, columns=cols, show='headings', height=14)
        for c, w in zip(cols, (160, 80, 90, 140, 90, 200)):
            self.tree.heading(c, text=c.capitalize())
            self.tree.column(c, width=w, anchor=tk.W)
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        sb = ttk.Scrollbar(left, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=sb.set)
        sb.pack(side=tk.LEFT, fill=tk.Y)
        self.tree.bind("<<TreeviewSelect>>", self._on_select_drone)
        paned.add(left, weight=3)
        # Right: details
        right = ttk.Frame(paned)
        df = ttk.LabelFrame(right, text="Drone Details", padding=8)
        df.pack(fill=tk.X)
        for label, var in (("ID", self.sel_id), ("Online", self.sel_online), ("Battery", self.sel_batt), ("Crypto", self.sel_crypto), ("Last Msg", self.sel_msg), ("Last Seen", self.sel_last)):
            row = ttk.Frame(df); row.pack(fill=tk.X, pady=2)
            ttk.Label(row, text=f"{label}:", width=12).pack(side=tk.LEFT)
            ttk.Label(row, textvariable=var).pack(side=tk.LEFT)
        cf = ttk.LabelFrame(right, text="Command", padding=8)
        cf.pack(fill=tk.X, pady=8)
        ttk.Label(cf, text="Command to selected:").pack(side=tk.LEFT)
        self.cmd_var = tk.StringVar(value="status")
        self.cmd_entry = ttk.Entry(cf, textvariable=self.cmd_var, width=20)
        self.cmd_entry.pack(side=tk.LEFT, padx=4)
        ttk.Button(cf, text="Send", command=self._send_individual_command).pack(side=tk.LEFT, padx=4)
        ttk.Button(cf, text="Request Status", command=lambda: self._set_and_send_cmd('status')).pack(side=tk.LEFT)
        paned.add(right, weight=2)

        # MAVLink tab
        mav_tab = ttk.Frame(notebook)
        notebook.add(mav_tab, text="MAVLink")

        # Connection frame
        cframe = ttk.LabelFrame(mav_tab, text="MAVLink Connection (via Proxy endpoints)", padding=8)
        cframe.pack(fill=tk.X, padx=8, pady=6)
        ttk.Label(cframe, text="RX URI").grid(row=0, column=0, sticky=tk.W)
        ttk.Entry(cframe, textvariable=self.mav_rx_uri, width=28).grid(row=0, column=1, padx=4)
        ttk.Label(cframe, text="TX URI").grid(row=0, column=2, sticky=tk.W)
        ttk.Entry(cframe, textvariable=self.mav_tx_uri, width=28).grid(row=0, column=3, padx=4)
        ttk.Label(cframe, text="SysID").grid(row=1, column=0, sticky=tk.W, pady=(4,0))
        ttk.Entry(cframe, textvariable=self.mav_sysid, width=6).grid(row=1, column=1, sticky=tk.W, pady=(4,0))
        ttk.Label(cframe, text="CompID").grid(row=1, column=2, sticky=tk.W, pady=(4,0))
        ttk.Entry(cframe, textvariable=self.mav_compid, width=6).grid(row=1, column=3, sticky=tk.W, pady=(4,0))
        ttk.Button(cframe, text="Connect", command=self._mav_connect).grid(row=0, column=4, padx=6)
        ttk.Button(cframe, text="Disconnect", command=self._mav_disconnect).grid(row=1, column=4)
        ttk.Label(cframe, textvariable=self.mav_status).grid(row=0, column=5, rowspan=2, padx=8)
        # Heartbeat controls
        ttk.Checkbutton(cframe, text="Auto HB", variable=self.mav_auto_hb).grid(row=0, column=6, padx=4)
        ttk.Button(cframe, text="Send HB", command=self._mav_send_hb).grid(row=1, column=6, padx=4)
        for i in range(7): cframe.grid_columnconfigure(i, weight=0)

        # Send frame
        sframe = ttk.LabelFrame(mav_tab, text="Send MAVLink", padding=8)
        sframe.pack(fill=tk.X, padx=8, pady=6)
        # quick commands
        ttk.Label(sframe, text="Target Sys/Comp").grid(row=0, column=0, sticky=tk.W)
        ttk.Entry(sframe, textvariable=self.mav_tgt_sys, width=6).grid(row=0, column=1)
        ttk.Entry(sframe, textvariable=self.mav_tgt_comp, width=6).grid(row=0, column=2)
        ttk.Button(sframe, text="ARM", command=lambda: self._mav_quick('arm')).grid(row=0, column=3, padx=4)
        ttk.Button(sframe, text="DISARM", command=lambda: self._mav_quick('disarm')).grid(row=0, column=4)
        ttk.Button(sframe, text="TAKEOFF", command=lambda: self._mav_quick('takeoff')).grid(row=0, column=5, padx=4)
        ttk.Button(sframe, text="LAND", command=lambda: self._mav_quick('land')).grid(row=0, column=6)
        # custom COMMAND_LONG
        ttk.Label(sframe, text="CMD ID").grid(row=1, column=0, sticky=tk.W, pady=(6,0))
        ttk.Entry(sframe, textvariable=self.mav_cmd_id, width=8).grid(row=1, column=1, pady=(6,0))
        for i in range(7):
            ttk.Label(sframe, text=f"P{i+1}").grid(row=1, column=2+i, sticky=tk.W, pady=(6,0))
            ttk.Entry(sframe, textvariable=self.mav_p[i], width=7).grid(row=2, column=2+i)
        ttk.Button(sframe, text="Send CMD_LONG", command=self._mav_send_cmd_long).grid(row=2, column=9, padx=8)
        # raw hex
        ttk.Label(sframe, text="Raw Hex").grid(row=3, column=0, sticky=tk.W, pady=(6,0))
        ttk.Entry(sframe, textvariable=self.mav_raw_hex, width=60).grid(row=3, column=1, columnspan=7, sticky=tk.W, pady=(6,0))
        ttk.Button(sframe, text="Send Raw", command=self._mav_send_raw).grid(row=3, column=8, padx=6, pady=(6,0))

        # Receive frame
        rframe = ttk.LabelFrame(mav_tab, text="Received MAVLink", padding=8)
        rframe.pack(fill=tk.BOTH, expand=True, padx=8, pady=6)
        self.mav_rx_txt = tk.Text(rframe, height=14)
        self.mav_rx_txt.pack(fill=tk.BOTH, expand=True)

        # Heartbeats tab (new)
        hb_tab = ttk.Frame(notebook)
        notebook.add(hb_tab, text="Heartbeats")
        hb_top = ttk.Frame(hb_tab); hb_top.pack(fill=tk.BOTH, expand=True, padx=8, pady=6)
        cols = ("sysid","compid","autopilot","type","base_mode","custom_mode","system_status","mver","last_seen","count")
        self.hb_tree = ttk.Treeview(hb_top, columns=cols, show='headings', height=14)
        for c,w in zip(cols,(60,60,90,90,80,90,110,50,140,60)): self.hb_tree.heading(c, text=c); self.hb_tree.column(c, width=w, anchor=tk.W)
        self.hb_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True); sb_hb = ttk.Scrollbar(hb_top, orient='vertical', command=self.hb_tree.yview); self.hb_tree.configure(yscrollcommand=sb_hb.set); sb_hb.pack(side=tk.LEFT, fill=tk.Y); self.hb_stats = {}  # (sysid, compid) -> dict

        # Logs tab
        logs_tab = ttk.Frame(notebook)
        notebook.add(logs_tab, text="Logs")
        toolbar = ttk.Frame(logs_tab)
        toolbar.pack(fill=tk.X, padx=8, pady=(8, 0))
        ttk.Button(toolbar, text="Clear", command=self._clear_log).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="Save", command=self._save_log).pack(side=tk.LEFT, padx=6)
        self.log_txt = tk.Text(logs_tab, height=18)
        self.log_txt.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        # Config tab (runtime IP editing)
        config_tab = ttk.Frame(notebook)
        notebook.add(config_tab, text="Config")
        if ip_config:
            lf_ips = ttk.LabelFrame(config_tab, text="Runtime IP Configuration", padding=8)
            lf_ips.pack(fill=tk.X, padx=8, pady=8)
            ttk.Label(lf_ips, text="GCS_HOST").grid(row=0, column=0, sticky=tk.W)
            ttk.Entry(lf_ips, textvariable=self.ipc_gcs, width=18).grid(row=0, column=1, padx=4, pady=2)
            ttk.Label(lf_ips, text="DRONE_HOST").grid(row=1, column=0, sticky=tk.W)
            ttk.Entry(lf_ips, textvariable=self.ipc_drone, width=18).grid(row=1, column=1, padx=4, pady=2)
            ttk.Button(lf_ips, text="Apply Runtime", command=self._apply_ip_runtime).grid(row=0, column=2, padx=8)
            ttk.Button(lf_ips, text="Apply & Persist", command=self._apply_ip_persistent).grid(row=1, column=2, padx=8)
            ttk.Button(lf_ips, text="Reload File", command=self._reload_ip_module).grid(row=0, column=3, padx=8)
            ttk.Button(lf_ips, text="Dark Mode", command=self._toggle_dark).grid(row=1, column=3, padx=8)
            for c in range(4): lf_ips.grid_columnconfigure(c, weight=0)
            lf_info = ttk.LabelFrame(config_tab, text="Notes", padding=8)
            lf_info.pack(fill=tk.BOTH, expand=True, padx=8, pady=(0,8))
            info_txt = (
                "Updates:\n"
                " - Runtime: changes available immediately to this GUI process only.\n"
                " - Persist: edits ip_config.py (previous value commented with timestamp).\n"
                "After persistent change, dependent proxy/core processes are restarted."
            )
            ttk.Label(lf_info, text=info_txt, justify=tk.LEFT).pack(anchor=tk.W)
        else:
            ttk.Label(config_tab, text="ip_config module not available").pack(pady=20)

        # Status bar
        sb_frame = ttk.Frame(self.root, relief=tk.SUNKEN)
        sb_frame.pack(side=tk.BOTTOM, fill=tk.X)
        ttk.Label(sb_frame, textvariable=self.sb_conn).pack(side=tk.LEFT, padx=8)
        ttk.Separator(sb_frame, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=6)
        ttk.Label(sb_frame, textvariable=self.sb_core).pack(side=tk.LEFT)
        ttk.Separator(sb_frame, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=6)
        ttk.Label(sb_frame, textvariable=self.sb_proxy).pack(side=tk.LEFT)
        ttk.Separator(sb_frame, orient=tk.VERTICAL).pack(side=tk.LEFT, fill=tk.Y, padx=6)
        ttk.Label(sb_frame, textvariable=self.sb_stats).pack(side=tk.RIGHT, padx=8)

    # Helper to set and send a quick command
    def _set_and_send_cmd(self, cmd: str):
        self.cmd_var.set(cmd)
        self._send_individual_command()

    # Log actions
    def _clear_log(self):
        self.log_txt.delete("1.0", tk.END)

    def _save_log(self):
        try:
            LOG_DIR.mkdir(exist_ok=True)
            fname = LOG_DIR / f"gcs_gui_log_{int(time.time())}.txt"
            with open(fname, 'w', encoding='utf-8') as f:
                f.write(self.log_txt.get("1.0", tk.END))
            self._log(f"Saved log to {fname}")
        except Exception as e:
            self._log(f"Save log failed: {e}")

    def _on_select_drone(self, _evt=None):
        sel = self.tree.selection()
        if not sel: return
        did = self.tree.item(sel[0], 'values')[0]
        info = self.drones.get(did)
        if not info: return
        self.sel_id.set(info.drone_id)
        self.sel_online.set("ONLINE" if info.online else "OFFLINE")
        self.sel_batt.set(f"{info.battery:.1f}%" if info.battery is not None else "-")
        self.sel_crypto.set(info.crypto or "-")
        self.sel_msg.set(info.last_msg_type or "-")
        self.sel_last.set(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(info.last_seen)))

    # MQTT thread + callbacks
    def _start_mqtt_thread(self):
        def run():
            try:
                self.mqtt=GcsMqttClient(self.config,self._on_mqtt_message); self._log("MQTT client initialized")
                if self.mqtt.connect():
                    if self.auto_start_core.get():
                        okc,msgc=self.core.start(); self._log(msgc)
                else: self._log("MQTT connect timeout")
            except Exception as e: self._log(f"MQTT init error: {e}")
        threading.Thread(target=run,daemon=True).start()

    def _on_mqtt_message(self, msg: mqtt.MQTTMessage):
        # enqueue for UI thread
        self.msg_queue.put(msg)

    # Actions
    def _connect(self):
        if not self.mqtt:
            # allow changing broker/port then reconnect thread
            try:
                self.config['broker']['address']=self.broker_entry.get().strip(); self.config['broker']['port']=int(self.port_entry.get().strip())
            except Exception: messagebox.showerror(APP_NAME,"Invalid broker/port"); return
            self._start_mqtt_thread()
        else:
            try: self.mqtt.disconnect(); self.mqtt.connect()
            except Exception as e: self._log(f"Reconnect error: {e}")

    def _apply_crypto(self):
        code=self.crypto_combo.get().split(" ")[0]
        topic=self.config['topics']['publish']['crypto']['topic']
        if self.mqtt and self.mqtt.connected:
            self.mqtt.publish(topic, code, qos=2); self._log(f"Published crypto command: {code}"); self._suppress_broadcast_until=time.time()+2.0; self._last_crypto_pub=code
        else: self._log("Cannot publish; not connected")
        if self.auto_local_crypto.get():
            ok,msg=self.crypto.switch(code); self._log(msg)

    def _send_alert(self, code:str, critical:bool):
        topic=self.config['topics']['publish']['alerts']['topic']
        if self.mqtt and self.mqtt.connected:
            # plain text for compatibility and retained if critical
            self.mqtt.publish(topic, code, qos=2, retain=critical)
            # structured as well
            payload = {"type": "alert", "code": code, "priority": "critical" if critical else "warning", "ts": time.time()}
            self.mqtt.publish(topic+"/json", payload, qos=2, retain=critical)
            self._log(f"Alert sent: {code}")
        else:
            self._log("Cannot send alert; not connected")

    def _send_individual_command(self):
        sel = self.tree.selection();
        if not sel: messagebox.showinfo(APP_NAME,"Select a drone first"); return
        # Ensure local proxy running if required
        if self.auto_local_crypto.get() and (self.crypto.proc is None or self.crypto.proc.poll() is not None):
            curr=self.crypto_combo.get().split(" ")[0]; ok,msg=self.crypto.switch(curr); self._log(msg)
        drone_id = self.tree.item(sel[0], 'values')[0]; cmd = self.cmd_var.get().strip() or "status"
        topic_tmpl = self.config['topics']['publish']['individual']['topic']
        topic = topic_tmpl.format(drone_id=drone_id)
        payload = {"type": "command", "command": cmd, "params": {}, "ts": time.time(), "source": "gcs"}
        if self.mqtt and self.mqtt.connected:
            ok = self.mqtt.publish(topic, payload, qos=1); self._log(f"Sent command '{cmd}' to {drone_id}: {'OK' if ok else 'FAIL'}")
        else:
            self._log("Cannot send; not connected")

    # MAVLink handlers
    def _mav_connect(self):
        ok,msg=self.mav.start(self.mav_rx_uri.get().strip(),self.mav_tx_uri.get().strip(),int(self.mav_sysid.get()),int(self.mav_compid.get()))
        if ok and self.mav_auto_hb.get(): self.mav.start_heartbeat()
        self.mav_status.set(("MAVLink: running" if ok else "MAVLink: stopped") + (" (pymavlink OK)" if PYMAVLINK_AVAILABLE else " (raw UDP mode)")); self._log(msg)
    def _mav_disconnect(self): self.mav.stop_heartbeat(); self.mav.stop(); self.mav_status.set("MAVLink: stopped" + (" (pymavlink OK)" if PYMAVLINK_AVAILABLE else " (raw UDP mode)")); self._log("MAVLink stopped")
    def _mav_send_hb(self): ok,msg=self.mav.send_heartbeat(); self._log(msg)
    def _mav_quick(self,what:str):
        if not PYMAVLINK_AVAILABLE: self._log("Install pymavlink for quick cmds"); return
        tgt_sys=int(self.mav_tgt_sys.get()); tgt_comp=int(self.mav_tgt_comp.get())
        if what=='arm': cmd=400; params=[1,0,0,0,0,0,0]
        elif what=='disarm': cmd=400; params=[0,0,0,0,0,0,0]
        elif what=='takeoff': cmd=22; params=[0,0,0,0,0,0,10.0]
        elif what=='land': cmd=21; params=[0,0,0,0,0,0,0]
        else: self._log("Unknown quick command"); return
        ok,msg=self.mav.send_command_long(tgt_sys,tgt_comp,cmd,params); self._log(msg)
    def _mav_send_cmd_long(self): tgt_sys=int(self.mav_tgt_sys.get()); tgt_comp=int(self.mav_tgt_comp.get()); cmd=int(self.mav_cmd_id.get()); params=[float(v.get()) for v in self.mav_p]; ok,msg=self.mav.send_command_long(tgt_sys,tgt_comp,cmd,params); self._log(msg)
    def _mav_send_raw(self):
        hx=self.mav_raw_hex.get().strip().replace(" ","")
        try: data=bytes.fromhex(hx)
        except Exception: self._log("Invalid hex"); return
        ok,msg=self.mav.send_raw(data); self._log(msg)
    def _on_mav_rx(self,msg):
        try:
            if PYMAVLINK_AVAILABLE:
                mtype=msg.get_type();
                if mtype=='HEARTBEAT': self._update_heartbeat(msg)
                line=f"{mtype} | {msg.to_dict()}"
            else:
                line=f"RAW {len(msg.get('raw')) if isinstance(msg,dict) and msg.get('raw') else 0} bytes"
        except Exception: line=str(msg)
        self.mav_rx_txt.insert(tk.END,line+"\n"); self.mav_rx_txt.see(tk.END)
    def _update_heartbeat(self,msg):
        try:
            sysid=getattr(msg,'sysid',None); compid=getattr(msg,'compid',None)
            if sysid is None or compid is None: return
            key=(sysid,compid); now=time.time(); rec=self.hb_stats.get(key)
            if rec: rec['count']+=1; rec['last_seen']=now
            else: rec={'count':1,'last_seen':now,'autopilot':getattr(msg,'autopilot','-'),'type':getattr(msg,'type','-'),'base_mode':getattr(msg,'base_mode','-'),'custom_mode':getattr(msg,'custom_mode','-'),'system_status':getattr(msg,'system_status','-'),'mver':getattr(msg,'mavlink_version','-')}; self.hb_stats[key]=rec
            rec.update({'autopilot':getattr(msg,'autopilot','-'),'type':getattr(msg,'type','-'),'base_mode':getattr(msg,'base_mode','-'),'custom_mode':getattr(msg,'custom_mode','-'),'system_status':getattr(msg,'system_status','-'),'mver':getattr(msg,'mavlink_version','-')})
            vals=(sysid,compid,rec['autopilot'],rec['type'],rec['base_mode'],rec['custom_mode'],rec['system_status'],rec['mver'],time.strftime('%H:%M:%S',time.localtime(rec['last_seen'])),rec['count'])
            iid=f"{sysid}-{compid}"; (self.hb_tree.item(iid,values=vals) if self.hb_tree.exists(iid) else self.hb_tree.insert('',tk.END,iid=iid,values=vals))
        except Exception as e: self._log(f"Heartbeat update error: {e}")
    # ---------------- IP UPDATE METHODS ----------------
    def _validate_ip(self, ip:str)->bool:
        import ipaddress
        try: ipaddress.IPv4Address(ip); return True
        except Exception: return False
    def _apply_ip_runtime(self):
        if not ip_config: self._log("ip_config unavailable"); return
        gcs=self.ipc_gcs.get().strip(); drone=self.ipc_drone.get().strip()
        if gcs and not self._validate_ip(gcs): self._log(f"Invalid GCS IP: {gcs}"); return
        if drone and not self._validate_ip(drone): self._log(f"Invalid DRONE IP: {drone}"); return
        try:
            changes=ip_config.set_hosts_runtime(gcs or None, drone or None)
            if changes: self._log("Runtime IP update: "+", ".join(changes)); self._restart_stack_after_ip_change()
            else: self._log("No runtime changes applied")
        except Exception as e: self._log(f"Runtime update failed: {e}")
    def _apply_ip_persistent(self):
        if not ip_config: self._log("ip_config unavailable"); return
        gcs=self.ipc_gcs.get().strip(); drone=self.ipc_drone.get().strip()
        if gcs and not self._validate_ip(gcs): self._log(f"Invalid GCS IP: {gcs}"); return
        if drone and not self._validate_ip(drone): self._log(f"Invalid DRONE IP: {drone}"); return
        try:
            changes=ip_config.update_hosts_persistent(gcs or None, drone or None)
            if changes: self._log("Persistent IP update: "+", ".join(changes)); self._reload_ip_module(); self._restart_stack_after_ip_change()
            else: self._log("No persistent changes applied")
        except Exception as e: self._log(f"Persistent update failed: {e}")
    def _reload_ip_module(self):
        if not ip_config: return
        try: importlib.reload(ip_config); self.ipc_gcs.set(getattr(ip_config,'GCS_HOST',self.ipc_gcs.get())); self.ipc_drone.set(getattr(ip_config,'DRONE_HOST',self.ipc_drone.get())); self._log("ip_config reloaded")
        except Exception as e: self._log(f"Reload failed: {e}")
    def update_ip(self, which:str, value:str, persistent:bool=True):
        if which not in ("gcs","drone"): raise ValueError("which must be 'gcs' or 'drone'")
        if not self._validate_ip(value): raise ValueError(f"Invalid IP: {value}")
        if persistent:
            if which=='gcs': ip_config.update_hosts_persistent(new_gcs=value,new_drone=None)
            else: ip_config.update_hosts_persistent(new_gcs=None,new_drone=value)
            self._reload_ip_module()
        else:
            if which=='gcs': ip_config.set_hosts_runtime(new_gcs=value,new_drone=None)
            else: ip_config.set_hosts_runtime(new_gcs=None,new_drone=value)
        (self.ipc_gcs if which=='gcs' else self.ipc_drone).set(value); self._restart_stack_after_ip_change(); self._log(f"update_ip completed ({which}->{value}, persistent={persistent})")
    def _restart_stack_after_ip_change(self):
        self._log("Restarting proxy/core after IP change ...")
        try:
            self.crypto.stop(); self.core.stop(); self.root.after(500,self._delayed_stack_restart)
        except Exception as e: self._log(f"Restart sequence error: {e}")
    def _delayed_stack_restart(self):
        code=self.crypto_combo.get().split(" ")[0]; ok,msg=self.crypto.switch(code); self._log(msg); 
        if self.auto_start_core.get(): okc,msgc=self.core.start(); self._log(msgc)
    # UI loop
    def _ui_tick(self):
        # status label
        if self.mqtt and self.mqtt.connected:
            self.status_lbl.config(text="Connected", foreground="green")
        else:
            self.status_lbl.config(text="Disconnected", foreground="red")

        # reflect core/proxy status
        core_running = bool(self.core and self.core.proc and self.core.proc.poll() is None)
        proxy_running = bool(self.crypto and self.crypto.proc and self.crypto.proc.poll() is None)
        self.core_status_lbl.config(text="Core: running" if core_running else "Core: stopped")
        cur = self.crypto.current_code or "?"
        self.proxy_status_lbl.config(text=f"Proxy: running ({cur})" if proxy_running else "Proxy: stopped")

        # update status bar
        broker = f"{self.config['broker']['address']}:{self.config['broker']['port']}"
        self.sb_conn.set(("Connected" if (self.mqtt and self.mqtt.connected) else "Disconnected") + f" @ {broker}")
        self.sb_core.set("Core: running" if core_running else "Core: stopped")
        self.sb_proxy.set(f"Proxy: running ({cur})" if proxy_running else "Proxy: stopped")
        total = len(self.drones)
        online = sum(1 for d in self.drones.values() if d.online)
        rx = (self.mqtt.metrics["rx"] if self.mqtt else 0)
        tx = (self.mqtt.metrics["tx"] if self.mqtt else 0)
        self.sb_stats.set(f"Drones: {online}/{total} | Rx: {rx}B Tx: {tx}B")

        # process MQTT messages
        try:
            while True:
                msg = self.msg_queue.get_nowait()
                self._handle_msg_on_ui(msg)
        except queue.Empty:
            pass

        # mark offline if stale (>60s)
        now = time.time()
        for did, info in list(self.drones.items()):
            if now - info.last_seen > 60 and info.online:
                info.online = False
                if self.tree.exists(did):
                    vals = self.tree.item(did, 'values')
                    new_vals = (did, "OFFLINE", vals[2], vals[3], vals[4], vals[5])
                    self.tree.item(did, values=new_vals)

        # reschedule
        self.root.after(300, self._ui_tick)

    # Message handling
    def _handle_msg_on_ui(self, msg: mqtt.MQTTMessage):
        topic = msg.topic
        payload = msg.payload
        text = None
        try:
            text = payload.decode('utf-8')
        except Exception:
            text = f"<binary {len(payload)} bytes>"

        # React to broadcast crypto commands
        if topic == self.config['topics']['publish']['crypto']['topic']:
            code = text.strip()
            if re.fullmatch(r"c[1-8]",code):
                # Ignore our own recent publish to prevent double-start
                if time.time() < self._suppress_broadcast_until and code == self._last_crypto_pub:
                    self._log(f"Ignoring self crypto broadcast: {code}")
                else:
                    self._log(f"Broadcast crypto received: {code}")
                    # update combo to reflect new selection
                    self._select_crypto_in_combo(code)
                    if self.auto_local_crypto.get():
                        # only switch if different from current
                        if code != (self.crypto.current_code or "") or not (self.crypto.proc and self.crypto.proc.poll() is not None):
                            ok,msg=self.crypto.switch(code); self._log(msg)
                return

        # Determine message type for UI display
        msg_type = None
        decoded = self._safe_json(text)
        if topic.startswith('swarm/heartbeat/') or '/heartbeat' in topic:
            msg_type = 'HEARTBEAT'
        elif isinstance(decoded,dict):
            tval = str(decoded.get('type') or decoded.get('message_type') or '').lower()
            if 'heartbeat' in tval:
                msg_type = 'HEARTBEAT'
            elif topic.startswith('swarm/status/') or '/status' in topic:
                msg_type = 'STATUS'
            elif ('/telemetry' in topic) or (topic.startswith('swarm/drones/') and topic.endswith('/telemetry')):
                msg_type = 'TELEMETRY'
            elif topic.startswith('swarm/alert/'):
                msg_type = 'ALERT'
        else:
            if topic.startswith('swarm/status/') or '/status' in topic:
                msg_type = 'STATUS'
            elif ('/telemetry' in topic) or (topic.startswith('swarm/drones/') and topic.endswith('/telemetry')):
                msg_type = 'TELEMETRY'
            elif topic.startswith('swarm/alert/'):
                msg_type = 'ALERT'

        # Update drones based on status/telemetry/alerts/heartbeat
        did = self._extract_drone_id(topic, decoded if isinstance(decoded,dict) else None)
        if did and did!="gcs":
            battery=None; crypto_alg=None
            if isinstance(decoded,dict):
                for k in ("battery","battery_percent","battery_level"):
                    if k in decoded:
                        try: battery=float(decoded[k]); break
                        except Exception: pass
                for k in ("crypto","crypto_algorithm"):
                    if k in decoded:
                        crypto_alg=str(decoded[k]); break
            self._upsert_drone(did,battery,msg_type or '-',crypto_alg)

        # Log
        if topic.startswith("swarm/alert/") and did: self._log(f"Alert from {did}: {text}")
        elif topic == self.config['topics']['publish']['alerts']['topic']: self._log(f"Broadcast alert: {text}")
        self._log(f"RX {topic}: {text}")

    def _safe_json(self, s: str):
        try:
            return json.loads(s)
        except Exception:
            return s

    def _extract_drone_id(self, topic: str, payload_obj: Optional[Dict[str, Any]] = None) -> Optional[str]:
        # Common patterns
        for pat in (
            r"swarm/status/([^/]+)",
            r"swarm/drones/([^/]+)/",
            r"swarm/alert/([^/]+)",
            r"swarm/heartbeat/([^/]+)",
            r"swarm/([^/]+)/status",
            r"swarm/([^/]+)/telemetry",
            r"swarm/([^/]+)/heartbeat",
        ):
            m = re.match(pat, topic)
            if m:
                return m.group(1)
        # Fallback: any 'swarm/<id>/' prefix
        m = re.match(r"swarm/([^/]+)/", topic)
        if m and m.group(1) not in ("broadcast", "status"):
            return m.group(1)
        # Try from payload
        if payload_obj:
            for key in ("drone_id", "id", "uav_id", "name"):
                v = payload_obj.get(key)
                if isinstance(v, str) and v.lower() != "gcs":
                    return v
        return None

    def _upsert_drone(self, drone_id:str, battery:Optional[float], msg_type:str='-', crypto_alg:Optional[str]=None):
        now=time.time(); info=self.drones.get(drone_id)
        if not info:
            info=DroneInfo(drone_id=drone_id,last_seen=now,online=True,battery=battery,crypto=crypto_alg,last_msg_type=msg_type)
            if msg_type=='HEARTBEAT': info.hb_count=1
            self.drones[drone_id]=info
            self.tree.insert('',tk.END,iid=drone_id,values=(drone_id,"ONLINE",f"{battery:.1f}%" if battery is not None else "-", crypto_alg or '-', msg_type, time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(now))))
        else:
            info.last_seen=now; info.online=True
            if battery is not None: info.battery=battery
            if crypto_alg: info.crypto=crypto_alg
            info.last_msg_type=msg_type
            if msg_type=='HEARTBEAT': info.hb_count+=1
            vals=(drone_id,"ONLINE",f"{info.battery:.1f}%" if info.battery is not None else "-", info.crypto or '-', info.last_msg_type or '-', time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(now)))
            (self.tree.item(drone_id,values=vals) if self.tree.exists(drone_id) else self.tree.insert('',tk.END,iid=drone_id,values=vals))

    def _log(self,line:str): ts=time.strftime("%H:%M:%S"); self.log_txt.insert(tk.END,f"[{ts}] {line}\n"); self.log_txt.see(tk.END); logger.info(line)

    # Core controls
    def _start_core(self): ok,msg=self.core.start(); self._log(msg)
    def _stop_core(self): self.core.stop(); self._log("Core stopped")
    def _start_proxy(self): code=self.crypto_combo.get().split(" ")[0]; ok,msg=self.crypto.switch(code); self._log(msg)
    def _stop_proxy(self): self.crypto.stop(); self._log("Proxy stopped")
    def _start_stack(self): code=self.crypto_combo.get().split(" ")[0]; ok,msg=self.crypto.switch(code); self._log(msg); okc,msgc=self.core.start(); self._log(msgc)
    def _select_crypto_in_combo(self,code:str):
        try:
            for idx,label in enumerate(self.crypto_combo['values']):
                if label.startswith(code+" "): self.crypto_combo.current(idx); break
        except Exception: pass

# --- Entrypoint ---
def main():
    root=tk.Tk(); app=GcsSchedulerApp(root, DEFAULT_CONFIG); root.mainloop()
if __name__ == "__main__": main()

-----------------
#!/usr/bin/env python3
"""
UAV Scheduler (v14.0 - Enhanced MQTT Security & Reliability)

- Implements modular, thread-safe MQTT communication architecture
- Provides robust certificate management and reconnection strategies
- Incorporates proper error handling and resource management
- Maintains secure TLS configuration with proper certificate validation
- Separates MQTT message handling from business logic using queue-based processing
"""

import os
import sys
import time
import signal
import logging
import subprocess
import psutil
import csv
import threading
import argparse
import json
import socket
import queue
import random
import ssl
from enum import IntEnum, Enum
from typing import Dict, List, Optional, Tuple, Any, Callable
from dataclasses import dataclass, asdict
import paho.mqtt.client as mqtt

# --- CONFIGURATION & SETUP ---
LOG_FILE = f'/tmp/uav_scheduler_v14_{os.getuid()}.log'
METRICS_CSV_FILE = f'/tmp/uav_metrics_{os.getuid()}.csv'
THREAT_FLAG_FILE = '/tmp/uav_threat.flag'
CRYPTO_FLAG_FILE = '/tmp/crypto.flag'

# --- LOGGING SETUP ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    filename=LOG_FILE
)
logger = logging.getLogger('UAVScheduler')
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setLevel(logging.INFO)
console_formatter = logging.Formatter('%(asctime)s - %(name)s: %(message)s')
console_handler.setFormatter(console_formatter)
logger.addHandler(console_handler)

# --- CORE DATA STRUCTURES & ENUMS ---
class TaskPriority(IntEnum):
    CRITICAL = 0
    HIGH = 1
    MEDIUM = 2

class AlgorithmType(str, Enum):
    TST = "tst"
    XGBOOST = "xgboost"
    MAVLINK = "mavlink"
    ASCON_128 = "ascon_128"
    KYBER_CRYPTO = "kyber_crypto"
    DILITHIUM2 = "dilithium2"
    FALCON512 = "falcon512"
    CAMELIA = "camellia"
    SPECK = "speck"
    HIGHT = "hight"

CRYPTO_OVERRIDE_MAP: Dict[int, AlgorithmType] = {
    1: AlgorithmType.ASCON_128,
    2: AlgorithmType.KYBER_CRYPTO,
    3: AlgorithmType.DILITHIUM2,
    4: AlgorithmType.FALCON512,
}

class ThreatLevel(IntEnum):
    NONE = 0
    POTENTIAL = 1
    CONFIRMING = 2
    CONFIRMED = 3

# --- Alert codes for MQTT communication ---
class AlertCode(str, Enum):
    CRITICAL = "awb-cri"
    CAUTION = "awb-cau"
    
class SwarmMessage(str, Enum):
    DDOS_DETECTED = "ddos_detected"
    SECURITY_CONCERN = "security_concern"
    THERMAL_EMERGENCY = "thermal_emergency"
    CRITICAL_BATTERY = "critical_battery"

# --- MQTT Configuration from standalone scripts ---
MQTT_BROKER_HOST = "192.168.0.103" # Your GCS Local IP
MQTT_BROKER_PORT = 8883

# Standard paths for certificates
STANDARD_CERT_PATHS = [
    "/home/dev/src/client/certs",
    "/home/dev/src/client",
    "/home/dev/swarm/certs",  # Corrected typo "swam" to "swarm"
    "/home/dev/certs"
]

# --- VENV PATHS ---
CRYPTO_ENV_PATH = "/home/dev/cenv"
DDOS_ENV_PATH = "/home/dev/nenv"
MAVLINK_ENV_PATH = "/home/dev/nenv"

@dataclass
class ResourceProfile:
    power_watts: float

@dataclass
class SystemState:
    timestamp: float = 0.0
    cpu_usage: float = 0.0
    memory_usage: float = 0.0
    battery_percent: float = 100.0
    temperature: float = 45.0
    power_draw_watts: float = 0.0
    threat_level: ThreatLevel = ThreatLevel.NONE

@dataclass
class Task:
    id: str
    name: str
    command: List[str]
    priority: TaskPriority
    algorithm: Optional[AlgorithmType] = None
    resource_profile: Optional[ResourceProfile] = None
    status: str = "CREATED"
    start_time: Optional[float] = None
    process: Optional[subprocess.Popen] = None
    pid: Optional[int] = None
    auto_restart: bool = False
    capture_output: bool = False  # NEW: stream stdout if True
    output_thread: Optional[threading.Thread] = None  # NEW: holder for streaming thread

# --- NEW: MQTT Message for thread-safe processing ---
@dataclass
class MQTTMessage:
    topic: str
    payload: bytes
    qos: int
    retain: bool = False

# --- NEW: Certificate Manager class ---
class CertificateManager:
    def __init__(self, drone_id: str):
        self.drone_id = drone_id
        self.ca_cert = None
        self.client_cert = None
        self.client_key = None
        self.cert_error = None
    
    def resolve_certificates(self) -> bool:
        """Resolve certificate paths using standard locations with proper validation"""
        for base_path in STANDARD_CERT_PATHS:
            if not os.path.isdir(base_path):
                continue
                
            # Try standard naming convention
            ca_path = os.path.join(base_path, "ca-cert.pem")
            cert_path = os.path.join(base_path, f"{self.drone_id}-cert.pem")
            key_path = os.path.join(base_path, f"{self.drone_id}-key.pem")
            
            # If not found, check clients subdirectory
            if not all(os.path.isfile(p) for p in [ca_path, cert_path, key_path]):
                clients_dir = os.path.join(base_path, "clients")
                if os.path.isdir(clients_dir):
                    ca_path = os.path.join(base_path, "ca-cert.pem")  # CA usually in parent dir
                    cert_path = os.path.join(clients_dir, f"{self.drone_id}-cert.pem")
                    key_path = os.path.join(clients_dir, f"{self.drone_id}-key.pem")
            
            # Validate all files exist
            if all(os.path.isfile(p) for p in [ca_path, cert_path, key_path]):
                # Verify certificate format
                try:
                    self._verify_cert_format(cert_path)
                    self._verify_cert_format(ca_path)
                    
                    self.ca_cert = ca_path
                    self.client_cert = cert_path
                    self.client_key = key_path
                    
                    logger.info(f"Valid certificates found in: {base_path}")
                    logger.info(f"Using CA: {ca_path}")
                    logger.info(f"Using cert: {cert_path}")
                    logger.info(f"Using key: {key_path}")
                    return True
                except Exception as e:
                    logger.warning(f"Invalid certificate format in {base_path}: {e}")
                    self.cert_error = str(e)
                    continue
        
        # No valid certificates found
        missing_detail = "No valid certificate paths found"
        logger.error(f"Certificate resolution failed: {missing_detail}")
        self.cert_error = missing_detail
        return False
    
    def _verify_cert_format(self, cert_path: str):
        """Basic verification that the file is a valid certificate"""
        try:
            with open(cert_path, 'r') as f:
                content = f.read()
                if "-----BEGIN CERTIFICATE-----" not in content:
                    raise ValueError(f"File does not contain a certificate header")
                if "-----END CERTIFICATE-----" not in content:
                    raise ValueError(f"File does not contain a certificate footer")
        except Exception as e:
            raise ValueError(f"Certificate verification failed: {str(e)}")

# --- NEW: MQTT Client with robust error handling and reconnection ---
class MQTTClient:
    # Reconnection parameters
    BASE_RECONNECT_WAIT = 1.0  # seconds
    MAX_RECONNECT_WAIT = 60.0  # max backoff of 1 minute
    
    def __init__(self, drone_id: str, message_callback: Callable[[MQTTMessage], None]):
        self.drone_id = drone_id
        self.client = None
        self.connected = False
        self.reconnect_count = 0
        self.message_callback = message_callback
        self.cert_manager = CertificateManager(drone_id)
        
        # Thread-safe message queue
        self.stop_event = threading.Event()
        self.reconnect_timer = None
        
        # Metrics
        self.metrics = {
            "messages_sent": 0,
            "messages_received": 0,
            "bytes_sent": 0,
            "bytes_received": 0,
            "connect_attempts": 0,
            "reconnect_attempts": 0,
            "connection_errors": 0
        }
        
        # Protocol version
        self.protocol_version = mqtt.MQTTv5
    
    def initialize(self) -> bool:
        """Initialize the MQTT client with certificate resolution"""
        if not self.cert_manager.resolve_certificates():
            logger.error(f"Failed to resolve certificates: {self.cert_manager.cert_error}")
            return False
            
        return self._setup_mqtt_client()
    
    def _setup_mqtt_client(self) -> bool:
        """Set up MQTT client with proper error handling and protocol negotiation"""
        try:
            # Try MQTT v5 first, then fall back as needed
            self._create_client_with_protocol()
            
            # Set up callbacks
            self.client.on_connect = self._on_connect
            self.client.on_disconnect = self._on_disconnect
            self.client.on_message = self._on_message
            self.client.on_publish = self._on_publish
            
            # Set up TLS with proper verification
            self._configure_tls_for_ip()
            
            logger.info(f"MQTT client setup completed.")
            return True
        except Exception as e:
            logger.error(f"Failed to setup MQTT client: {str(e)}", exc_info=True)
            self.client = None
            return False
    
    def _create_client_with_protocol(self):
        """Create client with protocol version negotiation"""
        try:
            # Try MQTT v5 first
            self.client = mqtt.Client(protocol=self.protocol_version, client_id=self.drone_id)
            logger.info(f"Using MQTT v5 protocol")
        except Exception as e:
            logger.warning(f"MQTT v5 not supported, falling back to v3.1.1: {e}")
            try:
                self.protocol_version = mqtt.MQTTv311
                self.client = mqtt.Client(protocol=self.protocol_version, client_id=self.drone_id)
                logger.info(f"Using MQTT v3.1.1 protocol")
            except Exception as e2:
                logger.warning(f"MQTT v3.1.1 not supported, using default client: {e2}")
                self.protocol_version = mqtt.MQTTv31
                self.client = mqtt.Client(client_id=self.drone_id)
                logger.info(f"Using default MQTT client")
    
    def _configure_tls_for_ip(self):
        """Configure TLS with CA validation; hostname disabled (IP broker). Optional pinning hook stub."""
        try:
            ctx = ssl.create_default_context(ssl.Purpose.SERVER_AUTH, cafile=self.cert_manager.ca_cert)
            ctx.check_hostname = False  # IP broker so no hostname match
            ctx.verify_mode = ssl.CERT_REQUIRED
            ctx.load_cert_chain(certfile=self.cert_manager.client_cert, keyfile=self.cert_manager.client_key)
            # Certificate pinning placeholder (uncomment & set expected_fp to enforce)
            # expected_fp = "SHA256:..."
            # def _pin(sock):
            #     cert = sock.getpeercert(binary_form=True)
            #     import hashlib
            #     fp = "SHA256:" + hashlib.sha256(cert).hexdigest().upper()
            #     if fp != expected_fp:
            #         raise ssl.SSLError("Server certificate fingerprint mismatch")
            self.client.tls_set_context(ctx)
            logger.info("TLS context configured (CA validated, hostname disabled for IP broker)")
        except ssl.SSLError as e:
            logger.error(f"SSL configuration error: {e}")
            raise ConnectionError(f"TLS setup failed: {e}")
        except FileNotFoundError as e:
            logger.error(f"Certificate file not found: {e}")
            raise ConnectionError(f"Missing certificate: {e}")
    
    def connect(self):
        """Connect to the MQTT broker with proper error handling"""
        if not self.client:
            logger.error("Cannot connect: MQTT client not initialized")
            return False
            
        try:
            self.metrics["connect_attempts"] += 1
            logger.info(f"Connecting to MQTT broker at {MQTT_BROKER_HOST}:{MQTT_BROKER_PORT}...")
            self.client.connect_async(MQTT_BROKER_HOST, MQTT_BROKER_PORT, 60)
            self.client.loop_start()
            return True
        except Exception as e:
            self.metrics["connection_errors"] += 1
            logger.error(f"Error connecting to MQTT broker: {str(e)}")
            return False
    
    def disconnect(self):
        """Disconnect from MQTT broker and cleanup resources"""
        self.stop_event.set()
        if self.reconnect_timer:
            self.reconnect_timer.cancel()
            
        if self.client and self.connected:
            try:
                self.client.disconnect()
                self.client.loop_stop()
                logger.info("MQTT client disconnected")
            except Exception as e:
                logger.error(f"Error during MQTT disconnect: {e}")
    
    def publish(self, topic: str, payload: dict, qos: int = 1) -> bool:
        """Publish a message to the MQTT broker with error handling"""
        if not self.client or not self.connected:
            logger.warning(f"Cannot publish to {topic}: MQTT client not connected")
            return False
            
        try:
            json_payload = json.dumps(payload)
            result = self.client.publish(topic, json_payload, qos=qos)
            
            if result.rc == mqtt.MQTT_ERR_SUCCESS:
                self.metrics["messages_sent"] += 1
                self.metrics["bytes_sent"] += len(json_payload)
                logger.info(f"Message published to {topic}")
                return True
            else:
                logger.warning(f"Failed to publish message to {topic}: {mqtt.error_string(result.rc)}")
                return False
        except Exception as e:
            logger.error(f"Error publishing message to {topic}: {str(e)}")
            return False
    
    def _on_connect(self, client, userdata, flags, rc, properties=None):
        """Handle connection to MQTT broker"""
        if rc == 0:
            self.connected = True
            self.reconnect_count = 0  # Reset reconnect counter on successful connection
            logger.info("Connected to MQTT broker")
            try:
                client.subscribe("swarm/broadcast/#", qos=1)
                client.subscribe(f"swarm/config/#", qos=2)
                # Subscribe to individual command topic
                client.subscribe(f"swarm/commands/individual/{self.drone_id}", qos=2)
                logger.info("Subscribed to swarm broadcast, config, and individual command channels")
            except Exception as e:
                logger.error(f"Failed to subscribe to topics: {e}")
        else:
            reason_str = {
                1: "incorrect protocol version",
                2: "invalid client identifier",
                3: "server unavailable",
                4: "bad username or password",
                5: "not authorised",
            }.get(rc, f"unknown error code {rc}")
            
            logger.error(f"MQTT connection failed: {reason_str}")
            logger.error(f"Connection details: broker={MQTT_BROKER_HOST}:{MQTT_BROKER_PORT}, client_id={self.drone_id}")
            self.connected = False
            self._schedule_reconnection()
    
    def _on_disconnect(self, client, userdata, rc, properties=None):
        """Handle disconnection from MQTT broker with exponential backoff reconnection"""
        self.connected = False
        reason_str = "clean disconnect" if rc == 0 else f"unexpected disconnect with code {rc}"
        logger.warning(f"Disconnected from MQTT broker. Reason: {reason_str}")
        
        # Try to reconnect with exponential backoff if not a clean disconnect
        if rc != 0 and not self.stop_event.is_set():
            self._schedule_reconnection()
    
    def _schedule_reconnection(self):
        """Schedule reconnection attempt with exponential backoff"""
        if self.stop_event.is_set():
            return
            
        self.metrics["reconnect_attempts"] += 1
        backoff_time = min(self.MAX_RECONNECT_WAIT, 
                          self.BASE_RECONNECT_WAIT * (2 ** min(self.reconnect_count, 6)))
        jitter = random.uniform(0, 0.5)  # Add jitter to avoid thundering herd
        wait_time = backoff_time + jitter
        
        logger.info(f"Scheduling reconnection in {wait_time:.2f} seconds (attempt {self.reconnect_count + 1})")
        
        # Cancel any existing timer
        if self.reconnect_timer:
            self.reconnect_timer.cancel()
            
        # Create new timer for reconnection
        self.reconnect_timer = threading.Timer(wait_time, self._reconnect)
        self.reconnect_timer.daemon = True
        self.reconnect_timer.start()
        self.reconnect_count += 1
    
    def _reconnect(self):
        """Attempt to reconnect to the MQTT broker"""
        if self.stop_event.is_set():
            return
            
        logger.info(f"Attempting to reconnect to MQTT broker...")
        try:
            if self.client:
                self.client.loop_stop()
                self.client.reconnect()
                self.client.loop_start()
        except Exception as e:
            logger.error(f"Reconnection attempt failed: {str(e)}")
            # Schedule next reconnection
            self._schedule_reconnection()
    
    def _on_message(self, client, userdata, msg):
        """Handle incoming MQTT messages with queue for thread safety"""
        try:
            # Record metrics
            self.metrics["messages_received"] += 1
            self.metrics["bytes_received"] += len(msg.payload)
            
            # Forward to callback for processing in main thread context
            if self.message_callback and not self.stop_event.is_set():
                mqtt_msg = MQTTMessage(
                    topic=msg.topic,
                    payload=msg.payload,
                    qos=msg.qos,
                    retain=msg.retain
                )
                self.message_callback(mqtt_msg)
        except Exception as e:
            logger.error(f"Error in MQTT message handler: {str(e)}")
    
    def _on_publish(self, client, userdata, mid):
        """Handle message publish acknowledgments"""
        logger.debug(f"Message {mid} published successfully")

class TheveninBatteryModel:
    def __init__(self, initial_soc=100.0):
        self.soc = initial_soc
        self.capacity = 5200.0
        self.nominal_voltage = 11.1
        self.last_update_time = time.time()

    def update(self, current_draw_amps: float) -> float:
        now = time.time()
        elapsed_seconds = now - self.last_update_time
        self.last_update_time = now
        if elapsed_seconds <= 0: return self.soc
        energy_drawn_Ah = (current_draw_amps * elapsed_seconds) / 3600.0
        soc_change = (energy_drawn_Ah / (self.capacity / 1000.0)) * 100
        self.soc = max(0.0, self.soc - soc_change)
        return self.soc

class DataLogger:
    def __init__(self, filename: str):
        self.filename = filename
        self.header = ['timestamp', 'cpu_usage', 'battery_percent', 'temperature', 'power_draw_watts', 'threat_level', 'active_ddos_model', 'active_crypto_model']
        try:
            with open(self.filename, 'w', newline='') as f:
                csv.writer(f).writerow(self.header)
            logger.info(f"Metrics will be logged to {self.filename}")
        except IOError as e:
            logger.error(f"Failed to create metrics log file: {e}")
            self.filename = None

    def log_state(self, state: SystemState, active_ddos_model: Optional[str], active_crypto_model: Optional[str]):
        if not self.filename: return
        try:
            log_data = asdict(state)
            log_data['active_ddos_model'] = active_ddos_model or "None"
            log_data['active_crypto_model'] = active_crypto_model or "None"
            log_data['threat_level'] = state.threat_level.name
            with open(self.filename, 'a', newline='') as f:
                writer = csv.DictWriter(f, fieldnames=self.header)
                writer.writerow({k: log_data[k] for k in self.header if k in log_data})
        except Exception as e:
            logger.warning(f"Could not write to metrics file: {e}")


class UAVScheduler:
    def __init__(self, config: Dict = None):
        self.config = self._load_config(config)
        self.drone_id = self.config.get("drone_id", "uav-drone-001")
        self.state = SystemState()
        self.battery_model = TheveninBatteryModel(self.config.get("initial_battery", 100.0))
        self.data_logger = DataLogger(METRICS_CSV_FILE)
        self.task_queue: List[Task] = []
        self.running_tasks: Dict[str, Task] = {}
        self.is_running = False
        self.lock = threading.RLock()
        self.monitor_thread = None
        
        self.current_ddos_model: Optional[AlgorithmType] = None
        self.ddos_task_id: Optional[str] = None
        self.tst_start_time: Optional[float] = None
        
        self.current_crypto_model: Optional[AlgorithmType] = None
        self.crypto_task_id: Optional[str] = None

        # --- NEW: Message queue for thread-safe processing ---
        self.message_queue = queue.Queue()
        self.message_processor_thread = None
        
        # --- NEW: Improved MQTT Client ---
        self.mqtt_client = MQTTClient(self.drone_id, self._queue_message)
        
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)

    def _load_config(self, user_config: Optional[Dict]) -> Dict:
        default_config = {
            "initial_battery": 100.0, "battery_critical_threshold": 20.0,
            "battery_low_threshold": 60.0, "tst_max_runtime_sec": 60.0,
            "thermal_emergency_threshold_c": 78.0, "drone_id": "uav-drone-001"
        }
        if user_config: default_config.update(user_config)
        return default_config

    # --- NEW: Thread-safe message handling ---
    def _queue_message(self, message: MQTTMessage):
        """Queue message for processing in main thread context"""
        self.message_queue.put(message)
    
    def _process_messages(self):
        """Process queued messages in a thread-safe manner"""
        while self.is_running:
            try:
                # Get message from queue with timeout to allow clean shutdown
                message = self.message_queue.get(timeout=0.5)
                
                # Process message with lock to avoid race conditions
                with self.lock:
                    self._handle_mqtt_message(message)
                    
                self.message_queue.task_done()
            except queue.Empty:
                # No messages in queue, continue
                continue
            except Exception as e:
                logger.error(f"Error processing message: {str(e)}")

    def _handle_mqtt_message(self, message: MQTTMessage):
        """Process MQTT message with proper validation and individual command support"""
        try:
            logger.info(f"Message received on topic '{message.topic}'")
            # Handle direct commands to this drone
            if message.topic == f"swarm/commands/individual/{self.drone_id}":
                try:
                    cmd = message.payload.decode().strip().lower()
                    logger.info(f"Received individual command: {cmd}")
                    if cmd == "status_update":
                        self._publish_heartbeat(force_full=True)
                    elif cmd == "rtl":
                        logger.warning("Received RTL command (Return to Launch) - implement as needed.")
                        # Implement RTL logic here
                    elif cmd == "hover":
                        logger.warning("Received HOVER command - implement as needed.")
                        # Implement hover logic here
                    else:
                        logger.warning(f"Unknown individual command: {cmd}")
                except Exception as e:
                    logger.error(f"Error handling individual command: {e}")
                return
            # Special handling for crypto messages which may be plain text
            if message.topic == 'swarm/broadcast/crypto':
                try:
                    crypto_text = message.payload.decode().strip()
                    logger.info(f"Received crypto command: {crypto_text}")
                    self._handle_crypto_command(crypto_text)
                    return
                except Exception as e:
                    logger.error(f"Error processing crypto command: {e}")
            # Special handling for alert messages which may be plain text
            if message.topic == 'swarm/broadcast/alert':
                try:
                    alert_code = message.payload.decode().strip()
                    logger.info(f"Received alert command: {alert_code}")
                    self._handle_alert_command(alert_code)
                    return
                except Exception as e:
                    logger.error(f"Error processing alert command: {e}")
            # Validate and decode payload for JSON messages
            try:
                payload = json.loads(message.payload.decode())
            except json.JSONDecodeError:
                logger.warning(f"Invalid JSON payload on topic {message.topic}")
                return
            # Process message based on topic
            if message.topic.startswith('swarm/config/'):
                self._handle_config_message(payload)
            elif message.topic.startswith('swarm/broadcast/'):
                self._handle_broadcast_message(payload)
        except Exception as e:
            logger.error(f"Error processing MQTT message: {str(e)}")
    def _publish_heartbeat(self, force_full: bool = False):
        if not self.mqtt_client or not self.mqtt_client.connected:
            return
        # Heartbeat documentation:
        # Topic: swarm/status/<drone_id>
        # Payload schema:
        # {
        #   "type": "heartbeat",
        #   "drone_id": "uav-drone-001",
        #   "timestamp": <epoch_float>,
        #   "threat_level": "NONE|POTENTIAL|CONFIRMING|CONFIRMED",
        #   "data": {
        #       "cpu_usage": <float percent>,
        #       "memory_usage": <float percent>,
        #       "temperature": <float C>,
        #       "power_draw_watts": <float>,
        #       "battery_percent": <float>,
        #       "threat_level": <repeat threat level>,
        #       "crypto_algorithm": <string or null>,
        #       "ddos_model": <string or null>
        #   }
        # }
        data = {
            "cpu_usage": self.state.cpu_usage,
            "memory_usage": self.state.memory_usage,
            "temperature": self.state.temperature,
            "power_draw_watts": self.state.power_draw_watts,
            "battery_percent": float(self.state.battery_percent),
            "threat_level": self.state.threat_level.name,
            "crypto_algorithm": self.current_crypto_model.value if self.current_crypto_model else None,
            "ddos_model": self.current_ddos_model.value if self.current_ddos_model else None,
        }
        payload = {
            "type": "heartbeat",
            "drone_id": self.drone_id,
            "timestamp": time.time(),
            "threat_level": self.state.threat_level.name,
            "data": data
        }
        self.mqtt_client.publish(f"swarm/status/{self.drone_id}", payload, qos=0)
    
    def _handle_config_message(self, payload: dict):
        """Handle configuration messages from GCS"""
        new_algo_str = payload.get("algorithm")
        if not new_algo_str:
            logger.warning("Config message missing algorithm field")
            return
            
        try:
            target_algorithm = AlgorithmType(new_algo_str)
            if self.current_crypto_model != target_algorithm:
                logger.critical(f"GCS DIRECTIVE: Switching crypto to {target_algorithm.value}")
                
                # Create task resources
                crypto_task = create_crypto_task(target_algorithm)
                
                # Stop old task with proper resource cleanup
                if self.crypto_task_id:
                    self._stop_task(self.crypto_task_id)
                    
                # Submit new task
                self.submit_task(crypto_task)
        except ValueError:
            logger.error(f"Invalid algorithm type: {new_algo_str}")
    
    def _handle_broadcast_message(self, payload: dict):
        """Handle broadcast messages from other drones"""
        original_sender = payload.get("original_sender")
        if not original_sender:
            logger.warning("Broadcast message missing original_sender field")
            return
        if original_sender != self.drone_id:
            alert = payload.get("alert", "No details")
            # Removed emoji for plain log
            logger.warning(f"SWARM ALERT relayed from {original_sender}: {alert}")
            if self.state.threat_level == ThreatLevel.NONE:
                self.state.threat_level = ThreatLevel.POTENTIAL
                logger.info("Elevating local threat level due to swarm alert.")
                
    def _handle_crypto_command(self, crypto_text: str):
        """Handle plain text crypto command from GCS"""
        try:
            # Check if it's a crypto command like c1, c2, etc.
            if crypto_text.startswith('c') and len(crypto_text) == 2 and crypto_text[1].isdigit():
                crypto_num = int(crypto_text[1])
                if 1 <= crypto_num <= 8:  # Validate range
                    logger.info(f"GCS DIRECTIVE: Received crypto command {crypto_text}")
                    
                    # Map command to algorithm
                    algorithm_map = {
                        1: AlgorithmType.ASCON_128,
                        2: AlgorithmType.KYBER_CRYPTO, 
                        3: AlgorithmType.DILITHIUM2,
                        4: AlgorithmType.FALCON512,
                        5: AlgorithmType.CAMELIA,
                        6: AlgorithmType.SPECK,
                        7: AlgorithmType.HIGHT,
                        8: AlgorithmType.ASCON_128  # Default backup
                    }
                    
                    target_algorithm = algorithm_map.get(crypto_num)
                    if target_algorithm and self.current_crypto_model != target_algorithm:
                        logger.critical(f"GCS DIRECTIVE: Switching crypto to {target_algorithm.value}")
                        
                        # Stop old task with proper resource cleanup
                        if self.crypto_task_id:
                            self._stop_task(self.crypto_task_id)
                            
                        # Submit new task
                        self.submit_task(create_crypto_task(target_algorithm))
                    return
            
            # If we get here, it's not a valid crypto command format
            logger.warning(f"Unrecognized crypto command format: {crypto_text}")
        except Exception as e:
            logger.error(f"Error processing crypto command {crypto_text}: {e}")
            
    def _handle_alert_command(self, alert_code: str):
        """Handle plain text alert command from GCS"""
        try:
            # Convert GCS alert codes to drone alert codes
            alert_code_map = {
                # GCS alert codes to drone alert codes
                "alb-cri": AlertCode.CRITICAL,
                "alb-cau": AlertCode.CAUTION,
            }
            # Process the alert code
            if alert_code in alert_code_map:
                received_alert = alert_code_map[alert_code]
                logger.critical(f"ALERT RECEIVED FROM GCS: {alert_code}")
                # Take appropriate action based on alert level
                if received_alert == AlertCode.CRITICAL:
                    logger.critical("IMPLEMENTING CRITICAL SECURITY MEASURES")
                    # Increase threat level
                    if self.state.threat_level < ThreatLevel.CONFIRMING:
                        self.state.threat_level = ThreatLevel.CONFIRMING
                    # Switch to high-security crypto
                    if self.current_crypto_model != AlgorithmType.FALCON512:
                        logger.info("Switching to FALCON512 crypto due to critical alert")
                        if self.crypto_task_id:
                            self._stop_task(self.crypto_task_id)
                        self.submit_task(create_crypto_task(AlgorithmType.FALCON512))
                    # Start TST scanning if not already running
                    if self.current_ddos_model != AlgorithmType.TST:
                        if self.ddos_task_id:
                            self._stop_task(self.ddos_task_id)
                        self.submit_task(create_ddos_task(AlgorithmType.TST))
                elif received_alert == AlertCode.CAUTION:
                    logger.warning("IMPLEMENTING HEIGHTENED SECURITY MEASURES")
                    # Increase threat level if currently none
                    if self.state.threat_level == ThreatLevel.NONE:
                        self.state.threat_level = ThreatLevel.POTENTIAL
            else:
                logger.warning(f"Unknown alert code received: {alert_code}")
        except Exception as e:
            logger.error(f"Error processing alert command {alert_code}: {e}")

    def _publish_threat_alert(self, alert_code: AlertCode, threat_data: Dict):
        """Publish threat alert with proper error handling"""
        if not self.mqtt_client:
            logger.warning("Cannot publish alert - MQTT client not initialized")
            return False
            
        # Create alert payload
        alert_payload = {
            "drone_id": self.drone_id,
            "timestamp": time.time(),
            "alert_code": alert_code.value,
            "data": threat_data
        }
        
        # Publish to alert topic
        alert_topic = f"swarm/alert/{self.drone_id}"
        result = self.mqtt_client.publish(alert_topic, alert_payload, qos=1)
        if result:
            logger.critical(f"ALERT PUBLISHED to GCS: {alert_code.value}")
        return result

    def _priority_to_nice(self, priority: TaskPriority) -> int:
        return {TaskPriority.CRITICAL: -20, TaskPriority.HIGH: -10, TaskPriority.MEDIUM: 0}.get(priority, 0)

    def submit_task(self, task: Task):
        with self.lock:
            self.task_queue.append(task)
            logger.info(f"Task '{task.name}' has been queued for execution.")

    def _start_task(self, task: Task) -> bool:
        if task.id in self.running_tasks:
            return False
        resources_allocated = []
        try:
            logger.info(f"Attempting to start task '{task.name}'...")
            if task.capture_output:
                process = subprocess.Popen(
                    task.command,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    bufsize=1,
                    preexec_fn=os.setsid
                )
            else:
                process = subprocess.Popen(
                    task.command,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    preexec_fn=os.setsid
                )
            resources_allocated.append(('process', process))
            task.pid = process.pid
            task.start_time = time.time()
            task.status = "RUNNING"
            self.running_tasks[task.id] = task
            resources_allocated.append(('task_registry', task.id))
            if task.pid:
                try:
                    psutil.Process(task.pid).nice(self._priority_to_nice(task.priority))
                except Exception as e:
                    logger.warning(f"Could not set priority for '{task.name}': {e}")
            if task.algorithm == AlgorithmType.TST:
                self.tst_start_time = task.start_time
                resources_allocated.append(('tst_time', True))
            if task.name.startswith("DDOS"):
                self.ddos_task_id = task.id
                self.current_ddos_model = task.algorithm
                resources_allocated.append(('ddos_model', task.algorithm))
            if task.name.startswith("Crypto"):
                self.crypto_task_id = task.id
                self.current_crypto_model = task.algorithm
                resources_allocated.append(('crypto_model', task.algorithm))
            logger.info(f"Task '{task.name}' started successfully (PID: {task.pid}).")
            if task.capture_output and process.stdout:
                task.output_thread = threading.Thread(target=self._stream_task_output, args=(task,), daemon=True)
                task.output_thread.start()
            return True
        except Exception as e:
            logger.error(f"A fatal error occurred while starting task '{task.name}': {e}")
            for resource_type, resource in reversed(resources_allocated):
                self._cleanup_resource(resource_type, resource, task)
            return False

    def _cleanup_resource(self, resource_type: str, resource, task: Optional[Task] = None):
        """Clean up allocated resources on failure"""
        try:
            if resource_type == 'process' and resource:
                try:
                    os.killpg(os.getpgid(resource.pid), signal.SIGKILL)
                except (ProcessLookupError, PermissionError):
                    pass
                    
            elif resource_type == 'task_registry':
                self.running_tasks.pop(resource, None)
                
            elif resource_type == 'tst_time':
                self.tst_start_time = None
                
            elif resource_type == 'ddos_model':
                self.ddos_task_id = None
                self.current_ddos_model = None
                
            elif resource_type == 'crypto_model':
                self.crypto_task_id = None
                self.current_crypto_model = None
                
        except Exception as e:
            logger.error(f"Error during resource cleanup ({resource_type}): {e}")

    def _stop_task(self, task_id: str):
        with self.lock:
            task = self.running_tasks.pop(task_id, None)
            if not task:
                return
            logger.info(f"Stopping task '{task.name}' (PID: {task.pid}).")
            if task.algorithm == AlgorithmType.TST:
                self.tst_start_time = None
            if task.id == self.ddos_task_id:
                self.ddos_task_id, self.current_ddos_model = None, None
            if task.id == self.crypto_task_id:
                self.crypto_task_id, self.current_crypto_model = None, None
            try:
                if task.pid:
                    os.killpg(os.getpgid(task.pid), signal.SIGKILL)
            except (ProcessLookupError, PermissionError):
                pass
            if task.output_thread and task.output_thread.is_alive():
                try:
                    task.output_thread.join(timeout=1.5)
                except Exception:
                    pass

    def _update_system_state(self):
        self.state.timestamp = time.time()
        self.state.cpu_usage, self.state.memory_usage = psutil.cpu_percent(), psutil.virtual_memory().percent
        try:
            with open('/sys/class/thermal/thermal_zone0/temp', 'r') as f: self.state.temperature = float(f.read().strip()) / 1000.0
        except Exception: self.state.temperature = 60.0
        base_power = 2.5 + (self.state.cpu_usage / 100.0 * 5.0)
        task_power = sum(t.resource_profile.power_watts for t in self.running_tasks.values())
        self.state.power_draw_watts = base_power + task_power
        current_draw = self.state.power_draw_watts / self.battery_model.nominal_voltage
        self.state.battery_percent = self.battery_model.update(current_draw)

    def _check_for_threat_signals(self):
        """Detect local threat indicators and raise to POTENTIAL only (state machine governs escalation)."""
        if os.path.exists(THREAT_FLAG_FILE):
            if self.state.threat_level == ThreatLevel.NONE:
                logger.warning("Threat flag detected: escalating to POTENTIAL")
                self.state.threat_level = ThreatLevel.POTENTIAL
            try:
                os.remove(THREAT_FLAG_FILE)
            except OSError:
                pass

    def _check_for_crypto_override(self):
        if not os.path.exists(CRYPTO_FLAG_FILE): return
        try:
            with open(CRYPTO_FLAG_FILE, 'r') as f: content = f.read().strip()
            
            target_algorithm = None
            if not content: # Empty file case
                target_algorithm = AlgorithmType.CAMELIA
            else: # Numbered case
                override_val = int(content)
                target_algorithm = CRYPTO_OVERRIDE_MAP.get(override_val)
            
            if target_algorithm and self.current_crypto_model != target_algorithm:
                logger.info(f"MANUAL OVERRIDE: Switching crypto to {target_algorithm.value}")
                if self.crypto_task_id: self._stop_task(self.crypto_task_id)
                self.submit_task(create_crypto_task(target_algorithm))
            
            os.remove(CRYPTO_FLAG_FILE)
        except Exception as e:
            logger.error(f"Could not process crypto override flag: {e}")

    def _manage_all_rounder_policy(self):
        """State machine for threat handling and resource governance."""
        s, c = self.state, self.config
        # Survival overrides
        if s.battery_percent < c["battery_critical_threshold"] or s.temperature > c["thermal_emergency_threshold_c"]:
            if self.ddos_task_id:
                self._stop_task(self.ddos_task_id)
            if s.threat_level != ThreatLevel.NONE:
                logger.info("Resetting threat level due to survival override")
            s.threat_level = ThreatLevel.NONE
            if not self.ddos_task_id and self.is_running:
                self.submit_task(create_ddos_task(AlgorithmType.XGBOOST))
            return

        # Ensure baseline XGBOOST in NONE state
        if s.threat_level == ThreatLevel.NONE:
            if not self.ddos_task_id and self.is_running:
                logger.debug("Starting baseline XGBOOST monitor")
                self.submit_task(create_ddos_task(AlgorithmType.XGBOOST))
            return

        # POTENTIAL -> start TST if resources allow and not already running
        if s.threat_level == ThreatLevel.POTENTIAL:
            if s.battery_percent < c["battery_low_threshold"]:
                logger.info("Deferring escalation due to low battery")
                return
            if self.current_ddos_model != AlgorithmType.TST:
                logger.info("Escalating to TST (CONFIRMING phase)")
                if self.ddos_task_id:
                    self._stop_task(self.ddos_task_id)
                self.submit_task(create_ddos_task(AlgorithmType.TST))
                s.threat_level = ThreatLevel.CONFIRMING
            return

        # CONFIRMING -> wait for TST completion or timeout
        if s.threat_level == ThreatLevel.CONFIRMING:
            task = self.running_tasks.get(self.ddos_task_id)
            runtime = 0
            if task and task.start_time:
                runtime = time.time() - task.start_time
            if runtime > c["tst_max_runtime_sec"]:
                logger.info("TST window elapsed; confirming threat")
                self._publish_threat_alert(AlertCode.CRITICAL, {"model": "TST", "finding": "DDoS Confirmed"})
                if self.ddos_task_id:
                    self._stop_task(self.ddos_task_id)
                s.threat_level = ThreatLevel.CONFIRMED
            return

        # CONFIRMED -> maintain posture (optionally could re-start lightweight monitor)
        if s.threat_level == ThreatLevel.CONFIRMED:
            if not self.ddos_task_id and self.is_running:
                # Optionally keep a monitoring process
                self.submit_task(create_ddos_task(AlgorithmType.XGBOOST))
            return

    def _monitor_loop(self):
        while self.is_running:
            with self.lock:
                self._update_system_state()
                self._check_for_crypto_override()
                self._check_for_threat_signals()
                self._manage_all_rounder_policy()
                if self.task_queue: self._start_task(self.task_queue.pop(0))
                self.data_logger.log_state(self.state,
                    self.current_ddos_model.value if self.current_ddos_model else None,
                    self.current_crypto_model.value if self.current_crypto_model else None)
                # Heartbeat after state update
                self._publish_heartbeat()
            time.sleep(2.0)

    def start(self):
        self.is_running = True
        
        # Initialize and connect MQTT client
        if self.mqtt_client.initialize():
            self.mqtt_client.connect()
        else:
            logger.error("Failed to initialize MQTT client - continuing without connectivity")
            
        # Start message processor thread
        self.message_processor_thread = threading.Thread(target=self._process_messages, daemon=True)
        self.message_processor_thread.start()
        
        # Start monitor thread
        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()
        
        logger.info("Scheduler v14.0 (Enhanced MQTT Security & Reliability) Started.")

    def stop(self):
        logger.info("Shutdown sequence initiated.")
        self.is_running = False
        
        # Disconnect MQTT client
        if self.mqtt_client:
            self.mqtt_client.disconnect()
            
        # Stop all tasks
        for task_id in list(self.running_tasks.keys()):
            self._stop_task(task_id)
            
        # Wait for threads to exit
        if self.monitor_thread and self.monitor_thread.is_alive():
            self.monitor_thread.join(timeout=2)
            
        if self.message_processor_thread and self.message_processor_thread.is_alive():
            self.message_processor_thread.join(timeout=2)
            
        logger.info("Scheduler stopped.")
        
    def _signal_handler(self, sig, frame):
        if not self.is_running: sys.exit(0)
        print("\nCtrl+C detected. Shutting down gracefully...")
        self.stop()

# --- TASK CREATION FUNCTIONS ---
def create_ddos_task(model: AlgorithmType) -> Task:
    venv_path = DDOS_ENV_PATH
    base_path = "/home/dev/src"
    script, pwr = ("ddos/testing/tst2.py", 4.5) if model == AlgorithmType.TST else ("ddos/xgboost/ddos_pipeline.py", 2.0)
    cmd = [f"{venv_path}/bin/python", f"{base_path}/{script}"]
    return Task(f"ddos-{model.value}-{int(time.time())}", f"DDOS {model.value}", cmd, TaskPriority.MEDIUM, model, ResourceProfile(pwr))

def create_crypto_task(algorithm: AlgorithmType) -> Task:
    venv_path = CRYPTO_ENV_PATH
    base_path = "/home/dev/src"
    
    script_map = {
        AlgorithmType.KYBER_CRYPTO: ("crypto/utils/drone_kyber_proxy.py", 2.5),
        AlgorithmType.CAMELIA: ("crypto/utils/custom_camellia/drone_camellia.py", 2.2),
        AlgorithmType.SPECK: ("crypto/pre-quantum/speck/drone_speck_proxy_final.py", 2.8),
        AlgorithmType.HIGHT: ("custom_hight/HIGHT-Python/drone_hight_final.py", 2.8),
        AlgorithmType.ASCON_128: ("crypto/utils/drone_ascon_proxy_final.py", 1.5),
        AlgorithmType.DILITHIUM2: ("crypto/utils/drone_dilithium_proxy.py", 2.6),
        AlgorithmType.FALCON512: ("crypto/utils/drone_falcon_proxy.py", 2.7)
    }
    script, pwr = script_map.get(algorithm, script_map[AlgorithmType.ASCON_128])
    
    cmd = [f"{venv_path}/bin/python", f"{base_path}/{script}"]
    return Task(f"crypto-{algorithm.value}-{int(time.time())}", f"Crypto {algorithm.value}", cmd, TaskPriority.HIGH, algorithm, ResourceProfile(pwr), auto_restart=True)

def create_mavlink_task() -> Task:
    venv_path = MAVLINK_ENV_PATH
    cmd = [f"{venv_path}/bin/mavproxy.py", "--master=/dev/ttyACM0", "--baudrate=921600", "--out=udp:127.0.0.1:5010"]
    return Task(
        f"mavlink-{int(time.time())}",
        "MAVLink Comms",
        cmd,
        TaskPriority.CRITICAL,
        AlgorithmType.MAVLINK,
        ResourceProfile(1.2),
        auto_restart=True,
        capture_output=True
    )


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="UAV Scheduler v14.0 - Enhanced MQTT Security & Reliability")
    parser.add_argument("--battery", type=float, default=100.0, help="Set initial battery percentage.")
    parser.add_argument("--drone_id", type=str, default="uav-drone-001", help="Set the unique ID for this drone.")
    args = parser.parse_args()

    if os.geteuid() != 0:
        logger.warning("Run with sudo to enable task priority setting.")

    # Clean up old flag files
    if os.path.exists(THREAT_FLAG_FILE): os.remove(THREAT_FLAG_FILE)
    if os.path.exists(CRYPTO_FLAG_FILE): os.remove(CRYPTO_FLAG_FILE)

    scheduler = UAVScheduler(config={"initial_battery": args.battery, "drone_id": args.drone_id})
    scheduler.start()

    # Submit baseline tasks (MAVLink, Crypto, XGBOOST monitor)
    scheduler.submit_task(create_mavlink_task())
    scheduler.submit_task(create_crypto_task(AlgorithmType.ASCON_128))
    scheduler.submit_task(create_ddos_task(AlgorithmType.XGBOOST))
    
    try:
        logger.info(f"Scheduler is running for drone: {args.drone_id}")
        logger.info(f"To simulate a local threat, run: touch {THREAT_FLAG_FILE}")
        logger.info(f"To manually rotate crypto, run: echo <1-4> > {CRYPTO_FLAG_FILE}")
        
        while scheduler.is_running:
            time.sleep(15)
            with scheduler.lock:
                s = scheduler.state
                ddos_model = scheduler.current_ddos_model.value if scheduler.current_ddos_model else "None"
                crypto_model = scheduler.current_crypto_model.value if scheduler.current_crypto_model else "None"
                print(f"\n--- [STATUS] Bat:{s.battery_percent:.1f}%|Temp:{s.temperature:.1f}°C|CPU:{s.cpu_usage:.1f}%|Threat:{s.threat_level.name}|DDoS:{ddos_model}|Crypto:{crypto_model} ---")
    except KeyboardInterrupt:
        pass
    finally:
        scheduler.stop()